<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>mandelbrot C++ g++ program | Q6600 Benchmarks Game </title>
<link href="../program.css" rel = "stylesheet" type = "text/css" >
<link rel="shortcut icon" href="../favicon.ico">
<header>
  <h3><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/q6600/">The&nbsp;Q6600<br>Benchmarks&nbsp;Game</a></h3>
</header>
<article>
  <div>
    <h1>mandelbrot C++ g++ program</h1>
    <aside>
      <p><a href="../description/mandelbrot.html#mandelbrot">description</a>
    </aside>
  </div>
  <section>
    <div>
      <h2>source code</h2>
    </div>
    <pre>
ï»¿<span class="slc">// The Computer Language Benchmarks Game</span>
<span class="slc">// https://salsa.debian.org/benchmarksgame-team/benchmarksgame/</span>
<span class="slc">//</span>
<span class="slc">// Contributed by Markus Flad</span>
<span class="slc">//</span>
<span class="slc">// compile with following g++ flags</span>
<span class="slc">//  -std=c++17 -O3 -Wall -march=native -mno-fma</span>

<span class="ppc">#include &lt;string&gt;</span>
<span class="ppc">#include &lt;iostream&gt;</span>
<span class="ppc">#include &lt;vector&gt;</span>
<span class="ppc">#include &lt;complex&gt;</span>
<span class="ppc">#include &lt;algorithm&gt;</span>
<span class="ppc">#include &lt;thread&gt;</span>
<span class="ppc">#include &lt;climits&gt;</span>
<span class="ppc">#if defined(__AVX512BW__) || defined(__AVX__) || defined(__SSE__)</span>
<span class="ppc">#include &lt;immintrin.h&gt;</span>
<span class="ppc">#endif</span>
<span class="ppc">#include &lt;stdlib.h&gt;</span>

<span class="slc">// Put everything in a namespace forces inlining</span>
<span class="kwa">namespace</span> <span class="opt">{</span>

<span class="kwb">const</span> <span class="kwc">auto</span> numberOfCpuCores <span class="opt">=</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwc">thread</span><span class="opt">::</span><span class="kwd">hardware_concurrency</span><span class="opt">();</span>

<span class="slc">// The PortableBinaryBitmap manages access to the pbm output file and provides</span>
<span class="slc">// interlaced canvases that allow threads to write to the bitmap in parallel.</span>
<span class="kwc">class</span> PortableBinaryBitmap <span class="opt">{</span>
<span class="kwc">public</span><span class="opt">:</span>
    <span class="kwa">using</span> Size<span class="opt">=</span><span class="kwc">std</span><span class="opt">::</span><span class="kwb">size_t</span><span class="opt">;</span>
    <span class="kwd">PortableBinaryBitmap</span><span class="opt">(</span><span class="kwc">std</span><span class="opt">::</span>ostream<span class="opt">&amp;</span> ostr<span class="opt">,</span> Size width<span class="opt">,</span> Size height<span class="opt">)</span>
    <span class="opt">:</span> <span class="kwd">_ostr</span> <span class="opt">(</span>ostr<span class="opt">)</span>
    <span class="opt">,</span> <span class="kwd">_width</span> <span class="opt">(</span><span class="kwd">roundToMultiple</span><span class="opt">(</span>width<span class="opt">,</span> CHAR_BIT<span class="opt">))</span>
    <span class="opt">,</span> <span class="kwd">_height</span> <span class="opt">(</span><span class="kwd">roundToMultiple</span><span class="opt">(</span>height<span class="opt">,</span> numberOfCpuCores<span class="opt">))</span>
    <span class="opt">,</span> <span class="kwd">_data</span> <span class="opt">((</span>_width <span class="opt">*</span> _height<span class="opt">) /</span> CHAR_BIT<span class="opt">) {</span>
        _ostr <span class="opt">&lt;&lt;</span> <span class="str">&quot;P4&quot;</span> <span class="opt">&lt;&lt;</span> <span class="str">&apos;</span><span class="esc">\n</span><span class="str">&apos;</span><span class="opt">;</span>
        _ostr <span class="opt">&lt;&lt;</span> _width <span class="opt">&lt;&lt;</span> <span class="str">&apos; &apos;</span> <span class="opt">&lt;&lt;</span> _height <span class="opt">&lt;&lt;</span> <span class="str">&apos;</span><span class="esc">\n</span><span class="str">&apos;</span><span class="opt">;</span>
    <span class="opt">}</span>
    <span class="opt">~</span><span class="kwd">PortableBinaryBitmap</span><span class="opt">() {</span>
        _ostr<span class="opt">.</span><span class="kwd">write</span><span class="opt">(</span>_data<span class="opt">.</span><span class="kwd">data</span><span class="opt">(),</span> _data<span class="opt">.</span><span class="kwd">size</span><span class="opt">());</span>
    <span class="opt">}</span>
    Size <span class="kwd">width</span><span class="opt">()</span> <span class="kwb">const</span> <span class="opt">{</span>
        <span class="kwa">return</span> _width<span class="opt">;</span>
    <span class="opt">}</span>
    Size <span class="kwd">height</span><span class="opt">()</span> <span class="kwb">const</span> <span class="opt">{</span>
        <span class="kwa">return</span> _height<span class="opt">;</span>
    <span class="opt">}</span>
    Size <span class="kwd">widthInBytes</span><span class="opt">()</span> <span class="kwb">const</span> <span class="opt">{</span>
        <span class="kwa">return</span> _width <span class="opt">/</span> CHAR_BIT<span class="opt">;</span>
    <span class="opt">}</span>
    <span class="kwb">struct</span> Line <span class="opt">{</span>
        <span class="kwc">constexpr</span> <span class="kwb">static</span> Size <span class="kwd">pixelsPerWrite</span><span class="opt">() {</span>
            <span class="kwa">return</span> CHAR_BIT<span class="opt">;</span>
        <span class="opt">}</span>
        Size y<span class="opt">;</span>
        Size width<span class="opt">;</span>
        <span class="kwb">char</span><span class="opt">*</span> data<span class="opt">;</span>
    <span class="opt">};</span>
    <span class="slc">// The InterlacedCanvas provides interlaced access to the bitmap data. Each</span>
    <span class="slc">// thread must use its own InterlacedCanvas to write to the bitmap.</span>
    <span class="kwc">class</span> InterlacedCanvas <span class="opt">{</span>
    <span class="kwc">public</span><span class="opt">:</span>
        <span class="kwc">class</span> Iterator <span class="opt">{</span>
        <span class="kwc">public</span><span class="opt">:</span>
            <span class="kwd">Iterator</span><span class="opt">(</span>Size y<span class="opt">,</span> Size _width<span class="opt">,</span> <span class="kwb">char</span><span class="opt">*</span> data<span class="opt">,</span>
                    Size interlaceIncrement<span class="opt">,</span> Size dataPointerIncrement<span class="opt">)</span>
            <span class="opt">:</span> _il <span class="opt">{</span>y<span class="opt">,</span> _width<span class="opt">,</span> data<span class="opt">}</span>
            <span class="opt">,</span> <span class="kwd">_interlaceIncrement</span> <span class="opt">(</span>interlaceIncrement<span class="opt">)</span>
            <span class="opt">,</span> <span class="kwd">_dataPointerIncrement</span> <span class="opt">(</span>dataPointerIncrement<span class="opt">) {</span>
            <span class="opt">}</span>
            Line<span class="opt">&amp;</span> <span class="kwc">operator</span><span class="opt">*() {</span>
                <span class="kwa">return</span> _il<span class="opt">;</span>
            <span class="opt">}</span>
            <span class="kwb">bool</span> <span class="kwc">operator</span><span class="opt">!=(</span><span class="kwb">const</span> Iterator<span class="opt">&amp;</span> other<span class="opt">)</span> <span class="kwb">const</span> <span class="opt">{</span>
                <span class="kwa">return</span> _il<span class="opt">.</span>data <span class="opt">!=</span> other<span class="opt">.</span>_il<span class="opt">.</span>data<span class="opt">;</span>
            <span class="opt">}</span>
            Iterator<span class="opt">&amp;</span> <span class="kwc">operator</span><span class="opt">++() {</span>
                _il<span class="opt">.</span>y <span class="opt">+=</span> _interlaceIncrement<span class="opt">;</span>
                _il<span class="opt">.</span>data <span class="opt">+=</span> _dataPointerIncrement<span class="opt">;</span>
                <span class="kwa">return</span> <span class="opt">*</span><span class="kwa">this</span><span class="opt">;</span>
            <span class="opt">}</span>
        <span class="kwc">private</span><span class="opt">:</span>
            Line _il<span class="opt">;</span>
            Size _interlaceIncrement<span class="opt">;</span>
            Size _dataPointerIncrement<span class="opt">;</span>
        <span class="opt">};</span>
        <span class="kwd">InterlacedCanvas</span><span class="opt">(</span>PortableBinaryBitmap<span class="opt">&amp;</span> pbm<span class="opt">,</span> Size yStart<span class="opt">,</span> Size increment<span class="opt">)</span>
        <span class="opt">:</span> <span class="kwd">_pbm</span> <span class="opt">(</span>pbm<span class="opt">)</span>
        <span class="opt">,</span> <span class="kwd">_yStart</span> <span class="opt">(</span>yStart<span class="opt">)</span>
        <span class="opt">,</span> <span class="kwd">_increment</span> <span class="opt">(</span>increment<span class="opt">)</span>
        <span class="opt">,</span> <span class="kwd">_dataStart</span> <span class="opt">(</span>yStart <span class="opt">*</span> pbm<span class="opt">.</span><span class="kwd">widthInBytes</span><span class="opt">())</span>
        <span class="opt">,</span> <span class="kwd">_dataPointerIncrement</span> <span class="opt">(</span>increment <span class="opt">*</span> pbm<span class="opt">.</span><span class="kwd">widthInBytes</span><span class="opt">()) {</span>
        <span class="opt">}</span>
        Size <span class="kwd">width</span><span class="opt">()</span> <span class="kwb">const</span> <span class="opt">{</span>
            <span class="kwa">return</span> _pbm<span class="opt">.</span><span class="kwd">width</span><span class="opt">();</span>
        <span class="opt">}</span>
        Size <span class="kwd">height</span><span class="opt">()</span> <span class="kwb">const</span> <span class="opt">{</span>
            <span class="kwa">return</span> _pbm<span class="opt">.</span><span class="kwd">height</span><span class="opt">();</span>
        <span class="opt">}</span>
        Iterator <span class="kwd">begin</span><span class="opt">() {</span>
            <span class="kwa">return</span> <span class="kwd">Iterator</span><span class="opt">(</span>_yStart<span class="opt">,</span> _pbm<span class="opt">.</span><span class="kwd">width</span><span class="opt">(),</span>
                    _pbm<span class="opt">.</span>_data<span class="opt">.</span><span class="kwd">data</span><span class="opt">() +</span> _dataStart<span class="opt">,</span>
                    _increment<span class="opt">,</span> _dataPointerIncrement<span class="opt">);</span>
        <span class="opt">}</span>
        Iterator <span class="kwd">end</span><span class="opt">() {</span>
            <span class="kwa">return</span> <span class="kwd">Iterator</span><span class="opt">(</span>_yStart <span class="opt">+</span> _pbm<span class="opt">.</span><span class="kwd">height</span><span class="opt">(),</span> _pbm<span class="opt">.</span><span class="kwd">width</span><span class="opt">(),</span>
                    _pbm<span class="opt">.</span>_data<span class="opt">.</span><span class="kwd">data</span><span class="opt">() +</span> _pbm<span class="opt">.</span>_data<span class="opt">.</span><span class="kwd">size</span><span class="opt">() +</span> _dataStart<span class="opt">,</span>
                    _increment<span class="opt">,</span> _dataPointerIncrement<span class="opt">);</span>
        <span class="opt">}</span>
    <span class="kwc">private</span><span class="opt">:</span>
        PortableBinaryBitmap<span class="opt">&amp;</span> _pbm<span class="opt">;</span>
        Size _yStart<span class="opt">;</span>
        Size _increment<span class="opt">;</span>
        Size _dataStart<span class="opt">;</span>
        Size _dataPointerIncrement<span class="opt">;</span>
    <span class="opt">};</span>
    <span class="kwc">std</span><span class="opt">::</span>vector<span class="opt">&lt;</span>InterlacedCanvas<span class="opt">&gt;</span> <span class="kwd">provideInterlacedCanvas</span><span class="opt">(</span>Size increment<span class="opt">)</span>
            noexcept <span class="opt">{</span>
        <span class="kwc">std</span><span class="opt">::</span>vector<span class="opt">&lt;</span>InterlacedCanvas<span class="opt">&gt;</span> interlacedCanvasVector<span class="opt">;</span>
        <span class="kwa">for</span> <span class="opt">(</span>Size yStart<span class="opt">=</span><span class="num">0</span><span class="opt">;</span> yStart<span class="opt">&lt;</span>increment<span class="opt">;</span> yStart<span class="opt">++) {</span>
            interlacedCanvasVector<span class="opt">.</span><span class="kwd">emplace_back</span><span class="opt">(*</span><span class="kwa">this</span><span class="opt">,</span> yStart<span class="opt">,</span> increment<span class="opt">);</span>
        <span class="opt">}</span>
        <span class="kwa">return</span> interlacedCanvasVector<span class="opt">;</span>
    <span class="opt">}</span>
    <span class="kwb">static</span> Size <span class="kwd">roundToMultiple</span> <span class="opt">(</span>Size number<span class="opt">,</span> Size base<span class="opt">) {</span>
        <span class="kwa">return</span> number <span class="opt">+ ((</span>number <span class="opt">%</span> base<span class="opt">) ? (</span>base <span class="opt">-</span> number <span class="opt">%</span> base<span class="opt">) :</span> <span class="num">0</span><span class="opt">);</span>
    <span class="opt">}</span>
<span class="kwc">private</span><span class="opt">:</span>
    <span class="kwc">std</span><span class="opt">::</span>ostream<span class="opt">&amp;</span> _ostr<span class="opt">;</span>
    Size _width<span class="opt">;</span>
    Size _height<span class="opt">;</span>
    <span class="kwc">std</span><span class="opt">::</span>vector<span class="opt">&lt;</span><span class="kwb">char</span><span class="opt">&gt;</span> _data<span class="opt">;</span>
<span class="opt">};</span>

<span class="slc">// If the system does not support SIMD, NoSimdUnion can be used.</span>
<span class="kwb">struct</span> NoSimdUnion <span class="opt">{</span>
    <span class="kwa">using</span> NumberType <span class="opt">=</span> <span class="kwb">double</span><span class="opt">;</span>
    <span class="kwa">using</span> SimdRegisterType <span class="opt">=</span> <span class="kwb">double</span><span class="opt">;</span>
    <span class="kwd">NoSimdUnion</span><span class="opt">()</span>
    <span class="opt">:</span> <span class="kwd">reg</span><span class="opt">(</span>val<span class="opt">) {</span>
    <span class="opt">}</span>
    <span class="kwd">NoSimdUnion</span><span class="opt">(</span><span class="kwb">const</span> NoSimdUnion<span class="opt">&amp;</span> other<span class="opt">)</span>
    <span class="opt">:</span> <span class="kwd">reg</span><span class="opt">(</span>val<span class="opt">) {</span>
        <span class="kwc">std</span><span class="opt">::</span><span class="kwd">copy</span><span class="opt">(</span><span class="kwc">std</span><span class="opt">::</span><span class="kwd">begin</span><span class="opt">(</span>other<span class="opt">.</span>val<span class="opt">),</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwd">end</span><span class="opt">(</span>other<span class="opt">.</span>val<span class="opt">),</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwd">begin</span><span class="opt">(</span>val<span class="opt">));</span>
    <span class="opt">}</span>
    NoSimdUnion<span class="opt">&amp;</span> <span class="kwc">operator</span><span class="opt">=(</span><span class="kwb">const</span> NoSimdUnion<span class="opt">&amp;</span> other<span class="opt">) {</span>
        <span class="kwc">std</span><span class="opt">::</span><span class="kwd">copy</span><span class="opt">(</span><span class="kwc">std</span><span class="opt">::</span><span class="kwd">begin</span><span class="opt">(</span>other<span class="opt">.</span>val<span class="opt">),</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwd">end</span><span class="opt">(</span>other<span class="opt">.</span>val<span class="opt">),</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwd">begin</span><span class="opt">(</span>val<span class="opt">));</span>
        <span class="kwa">return</span> <span class="opt">*</span><span class="kwa">this</span><span class="opt">;</span>
    <span class="opt">}</span>
    <span class="kwb">bool</span> <span class="kwc">operator</span><span class="opt">&gt;(</span><span class="kwb">const double</span><span class="opt">&amp;</span> threshold<span class="opt">)</span> <span class="kwb">const</span> <span class="opt">{</span>
        <span class="kwa">return</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwd">all_of</span><span class="opt">(</span><span class="kwc">std</span><span class="opt">::</span><span class="kwd">begin</span><span class="opt">(</span>val<span class="opt">),</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwd">end</span><span class="opt">(</span>val<span class="opt">),</span>
                <span class="opt">[&amp;</span>threshold<span class="opt">](</span><span class="kwb">double</span> v<span class="opt">) {</span>
            <span class="kwa">return</span> v <span class="opt">&gt;</span> threshold<span class="opt">;</span>
        <span class="opt">});</span>
    <span class="opt">}</span>
    <span class="kwb">char</span> <span class="kwd">lteToPixels</span><span class="opt">(</span><span class="kwb">double</span> threshold<span class="opt">)</span> <span class="kwb">const</span> <span class="opt">{</span>
        <span class="kwb">char</span> result <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
        <span class="kwa">if</span> <span class="opt">(</span>val<span class="opt">[</span><span class="num">0</span><span class="opt">] &lt;=</span> threshold<span class="opt">)</span> result <span class="opt">|=</span> <span class="num">0b10000000</span><span class="opt">;</span>
        <span class="kwa">if</span> <span class="opt">(</span>val<span class="opt">[</span><span class="num">1</span><span class="opt">] &lt;=</span> threshold<span class="opt">)</span> result <span class="opt">|=</span> <span class="num">0b01000000</span><span class="opt">;</span>
        <span class="kwa">if</span> <span class="opt">(</span>val<span class="opt">[</span><span class="num">2</span><span class="opt">] &lt;=</span> threshold<span class="opt">)</span> result <span class="opt">|=</span> <span class="num">0b00100000</span><span class="opt">;</span>
        <span class="kwa">if</span> <span class="opt">(</span>val<span class="opt">[</span><span class="num">3</span><span class="opt">] &lt;=</span> threshold<span class="opt">)</span> result <span class="opt">|=</span> <span class="num">0b00010000</span><span class="opt">;</span>
        <span class="kwa">if</span> <span class="opt">(</span>val<span class="opt">[</span><span class="num">4</span><span class="opt">] &lt;=</span> threshold<span class="opt">)</span> result <span class="opt">|=</span> <span class="num">0b00001000</span><span class="opt">;</span>
        <span class="kwa">if</span> <span class="opt">(</span>val<span class="opt">[</span><span class="num">5</span><span class="opt">] &lt;=</span> threshold<span class="opt">)</span> result <span class="opt">|=</span> <span class="num">0b00000100</span><span class="opt">;</span>
        <span class="kwa">if</span> <span class="opt">(</span>val<span class="opt">[</span><span class="num">6</span><span class="opt">] &lt;=</span> threshold<span class="opt">)</span> result <span class="opt">|=</span> <span class="num">0b00000010</span><span class="opt">;</span>
        <span class="kwa">if</span> <span class="opt">(</span>val<span class="opt">[</span><span class="num">7</span><span class="opt">] &lt;=</span> threshold<span class="opt">)</span> result <span class="opt">|=</span> <span class="num">0b00000001</span><span class="opt">;</span>
        <span class="kwa">return</span> result<span class="opt">;</span>
    <span class="opt">}</span>
    SimdRegisterType<span class="opt">*</span> reg<span class="opt">;</span>
    NumberType val<span class="opt">[</span><span class="num">8</span><span class="opt">];</span>
<span class="opt">};</span>

<span class="ppc">#if defined(__AVX512BW__) || defined(__AVX__) || defined(__SSE__)</span>
<span class="kwb">union</span> Simd128DUnion <span class="opt">{</span>
    <span class="kwa">using</span> NumberType <span class="opt">=</span> <span class="kwb">double</span><span class="opt">;</span>
    <span class="kwa">using</span> SimdRegisterType <span class="opt">=</span> __m128d<span class="opt">;</span>
    SimdRegisterType reg<span class="opt">[</span><span class="num">4</span><span class="opt">];</span>
    NumberType val<span class="opt">[</span><span class="num">8</span><span class="opt">];</span>
    <span class="kwb">bool</span> <span class="kwc">operator</span><span class="opt">&gt;(</span><span class="kwb">const</span> __m128d<span class="opt">&amp;</span> threshold<span class="opt">)</span> <span class="kwb">const</span> <span class="opt">{</span>
        <span class="slc">// Note: Architectures like core2 provide SSE, but no VCMPGTPD</span>
        <span class="slc">// (greater-than) instruction. Therefore we use vcmplepd (less-equal)</span>
        <span class="slc">// and invert.</span>
        <span class="kwa">return</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwd">all_of</span><span class="opt">(</span><span class="kwc">std</span><span class="opt">::</span><span class="kwd">begin</span><span class="opt">(</span>reg<span class="opt">),</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwd">end</span><span class="opt">(</span>reg<span class="opt">),</span>
                <span class="opt">[&amp;</span>threshold<span class="opt">](</span>__m128d r<span class="opt">) {</span>
            __m128d cmpRes <span class="opt">=</span> <span class="kwd">_mm_cmple_pd</span><span class="opt">(</span>r<span class="opt">,</span> threshold<span class="opt">);</span>
            <span class="kwa">return</span> <span class="opt">!</span><span class="kwd">_mm_movemask_pd</span><span class="opt">(</span>cmpRes<span class="opt">);</span>
        <span class="opt">});</span>
    <span class="opt">}</span>
    <span class="kwb">char</span> <span class="kwd">lteToPixels</span><span class="opt">(</span><span class="kwb">const</span> __m128d<span class="opt">&amp;</span> threshold<span class="opt">)</span> <span class="kwb">const</span> <span class="opt">{</span>
        __m128d r0 <span class="opt">=</span> <span class="kwd">_mm_cmple_pd</span><span class="opt">(</span>reg<span class="opt">[</span><span class="num">0</span><span class="opt">],</span> threshold<span class="opt">);</span>
        __m128d r1 <span class="opt">=</span> <span class="kwd">_mm_cmple_pd</span><span class="opt">(</span>reg<span class="opt">[</span><span class="num">1</span><span class="opt">],</span> threshold<span class="opt">);</span>
        __m128d r2 <span class="opt">=</span> <span class="kwd">_mm_cmple_pd</span><span class="opt">(</span>reg<span class="opt">[</span><span class="num">2</span><span class="opt">],</span> threshold<span class="opt">);</span>
        __m128d r3 <span class="opt">=</span> <span class="kwd">_mm_cmple_pd</span><span class="opt">(</span>reg<span class="opt">[</span><span class="num">3</span><span class="opt">],</span> threshold<span class="opt">);</span>
        <span class="kwb">char</span> c0 <span class="opt">=</span> <span class="kwd">_mm_movemask_pd</span><span class="opt">(</span>r0<span class="opt">);</span>
        <span class="kwb">char</span> c1 <span class="opt">=</span> <span class="kwd">_mm_movemask_pd</span><span class="opt">(</span>r1<span class="opt">);</span>
        <span class="kwb">char</span> c2 <span class="opt">=</span> <span class="kwd">_mm_movemask_pd</span><span class="opt">(</span>r2<span class="opt">);</span>
        <span class="kwb">char</span> c3 <span class="opt">=</span> <span class="kwd">_mm_movemask_pd</span><span class="opt">(</span>r3<span class="opt">);</span>
        c0 <span class="opt">&lt;&lt;=</span> <span class="num">6</span><span class="opt">;</span>
        c1 <span class="opt">&lt;&lt;=</span> <span class="num">4</span><span class="opt">;</span>
        c2 <span class="opt">&lt;&lt;=</span> <span class="num">2</span><span class="opt">;</span>
        <span class="kwa">return</span> c0 <span class="opt">|</span> c1 <span class="opt">|</span> c2 <span class="opt">|</span> c3<span class="opt">;</span>
    <span class="opt">}</span>
<span class="opt">};</span>

<span class="kwb">union</span> Simd256DUnion <span class="opt">{</span>
    <span class="kwa">using</span> NumberType <span class="opt">=</span> <span class="kwb">double</span><span class="opt">;</span>
    <span class="kwa">using</span> SimdRegisterType <span class="opt">=</span> __m256d<span class="opt">;</span>
    SimdRegisterType reg<span class="opt">[</span><span class="num">2</span><span class="opt">];</span>
    NumberType val<span class="opt">[</span><span class="num">8</span><span class="opt">];</span>
    <span class="kwb">bool</span> <span class="kwc">operator</span><span class="opt">&gt;(</span><span class="kwb">const</span> __m256d<span class="opt">&amp;</span> threshold<span class="opt">)</span> <span class="kwb">const</span> <span class="opt">{</span>
        <span class="slc">// Note: Architectures like Haswell provide AVX-2, but no VCMPGTPD</span>
        <span class="slc">// (greater-than) instruction. Therefore we use vcmplepd (less-equal).</span>
        <span class="kwa">return</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwd">all_of</span><span class="opt">(</span><span class="kwc">std</span><span class="opt">::</span><span class="kwd">begin</span><span class="opt">(</span>reg<span class="opt">),</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwd">end</span><span class="opt">(</span>reg<span class="opt">),</span>
                <span class="opt">[&amp;</span>threshold<span class="opt">](</span>__m256d r<span class="opt">) {</span>
            __m256d cmpRes <span class="opt">=</span> <span class="kwd">_mm256_cmp_pd</span><span class="opt">(</span>r<span class="opt">,</span> threshold<span class="opt">,</span> _CMP_LE_OQ<span class="opt">);</span>
            <span class="kwa">return</span> <span class="kwd">_mm256_testz_pd</span><span class="opt">(</span>cmpRes<span class="opt">,</span> cmpRes<span class="opt">);</span>
        <span class="opt">});</span>
    <span class="opt">}</span>
    <span class="kwb">char</span> <span class="kwd">lteToPixels</span><span class="opt">(</span><span class="kwb">const</span> __m256d<span class="opt">&amp;</span> threshold<span class="opt">)</span> <span class="kwb">const</span> <span class="opt">{</span>
        __m256d r0 <span class="opt">=</span> <span class="kwd">_mm256_cmp_pd</span><span class="opt">(</span>reg<span class="opt">[</span><span class="num">0</span><span class="opt">],</span> threshold<span class="opt">,</span> _CMP_LE_OQ<span class="opt">);</span>
        __m256d r1 <span class="opt">=</span> <span class="kwd">_mm256_cmp_pd</span><span class="opt">(</span>reg<span class="opt">[</span><span class="num">1</span><span class="opt">],</span> threshold<span class="opt">,</span> _CMP_LE_OQ<span class="opt">);</span>
        <span class="kwb">char</span> c0 <span class="opt">=</span> <span class="kwd">_mm256_movemask_pd</span><span class="opt">(</span>r0<span class="opt">);</span>
        <span class="kwb">char</span> c1 <span class="opt">=</span> <span class="kwd">_mm256_movemask_pd</span><span class="opt">(</span>r1<span class="opt">);</span>
        c0 <span class="opt">&lt;&lt;=</span> <span class="num">4</span><span class="opt">;</span>
        <span class="kwa">return</span> c0 <span class="opt">|</span> c1<span class="opt">;</span>
    <span class="opt">}</span>
<span class="opt">};</span>

<span class="kwb">union</span> Simd512DUnion <span class="opt">{</span>
    <span class="kwa">using</span> NumberType <span class="opt">=</span> <span class="kwb">double</span><span class="opt">;</span>
    <span class="kwa">using</span> SimdRegisterType <span class="opt">=</span> __m512d<span class="opt">;</span>
    SimdRegisterType reg<span class="opt">[</span><span class="num">1</span><span class="opt">];</span>
    NumberType val<span class="opt">[</span><span class="num">8</span><span class="opt">];</span>
    <span class="kwb">bool</span> <span class="kwc">operator</span><span class="opt">&gt;(</span><span class="kwb">const</span> __m512d<span class="opt">&amp;</span> threshold<span class="opt">)</span> <span class="kwb">const</span> <span class="opt">{</span>
        <span class="kwa">return</span> <span class="kwd">_mm512_cmp_pd_mask</span><span class="opt">(</span>reg<span class="opt">[</span><span class="num">0</span><span class="opt">],</span> threshold<span class="opt">,</span> _CMP_GT_OQ<span class="opt">);</span>
    <span class="opt">}</span>
    <span class="kwb">char</span> <span class="kwd">lteToPixels</span><span class="opt">(</span><span class="kwb">const</span> __m512d<span class="opt">&amp;</span> threshold<span class="opt">)</span> <span class="kwb">const</span> <span class="opt">{</span>
        <span class="kwa">return</span> <span class="kwd">_mm512_cmp_pd_mask</span><span class="opt">(</span>reg<span class="opt">[</span><span class="num">0</span><span class="opt">],</span> threshold<span class="opt">,</span> _CMP_LE_OQ<span class="opt">);</span>
    <span class="opt">}</span>
<span class="opt">};</span>
<span class="ppc">#endif</span> <span class="slc">// defined(__AVX512BW__) || defined(__AVX__) || defined(__SSE__)</span>
<span class="ppc"></span>
<span class="kwc">template</span><span class="opt">&lt;</span><span class="kwc">class</span> SimdUnion<span class="opt">&gt;</span>
<span class="kwc">constexpr std</span><span class="opt">::</span><span class="kwb">size_t</span> <span class="kwd">numberOfNumbers</span><span class="opt">() {</span>
    <span class="kwa">return sizeof</span><span class="opt">(</span><span class="kwc">SimdUnion</span><span class="opt">::</span>val<span class="opt">) /</span> <span class="kwa">sizeof</span><span class="opt">(</span>typename <span class="kwc">SimdUnion</span><span class="opt">::</span>NumberType<span class="opt">);</span>
<span class="opt">}</span>
<span class="kwc">template</span><span class="opt">&lt;</span><span class="kwc">class</span> SimdUnion<span class="opt">&gt;</span>
<span class="kwc">constexpr std</span><span class="opt">::</span><span class="kwb">size_t</span> <span class="kwd">numberOfNumbersInRegister</span><span class="opt">() {</span>
    <span class="kwa">return sizeof</span><span class="opt">(</span>typename <span class="kwc">SimdUnion</span><span class="opt">::</span>SimdRegisterType<span class="opt">) /</span>
            <span class="kwa">sizeof</span><span class="opt">(</span>typename <span class="kwc">SimdUnion</span><span class="opt">::</span>NumberType<span class="opt">);</span>
<span class="opt">}</span>
<span class="kwc">template</span><span class="opt">&lt;</span><span class="kwc">class</span> SimdUnion<span class="opt">&gt;</span>
<span class="kwc">constexpr std</span><span class="opt">::</span><span class="kwb">size_t</span> <span class="kwd">numberOfRegisters</span><span class="opt">() {</span>
    <span class="kwa">return</span> numberOfNumbers<span class="opt">&lt;</span>SimdUnion<span class="opt">&gt;() /</span>
            numberOfNumbersInRegister<span class="opt">&lt;</span>SimdUnion<span class="opt">&gt;();</span>
<span class="opt">}</span>
<span class="kwc">template</span><span class="opt">&lt;</span><span class="kwc">class</span> SimdUnion<span class="opt">&gt;</span>
<span class="kwb">void</span> <span class="kwd">setValueInReg</span><span class="opt">(</span>typename <span class="kwc">SimdUnion</span><span class="opt">::</span>SimdRegisterType<span class="opt">&amp;</span> reg<span class="opt">,</span>
              typename <span class="kwc">SimdUnion</span><span class="opt">::</span>NumberType v<span class="opt">) {</span>
    <span class="kwa">using</span> SimdRegisterType <span class="opt">=</span> typename <span class="kwc">SimdUnion</span><span class="opt">::</span>SimdRegisterType<span class="opt">;</span>
    <span class="kwc">constexpr auto</span> numbersInReg <span class="opt">=</span> numberOfNumbersInRegister<span class="opt">&lt;</span>SimdUnion<span class="opt">&gt;();</span>
    <span class="kwa">if</span> <span class="kwc">constexpr</span> <span class="opt">(</span>numbersInReg <span class="opt">==</span> <span class="num">1</span><span class="opt">) {</span>
        reg <span class="opt">=</span> v<span class="opt">;</span>
    <span class="opt">}</span> <span class="kwa">else if</span> <span class="kwc">constexpr</span> <span class="opt">(</span>numbersInReg <span class="opt">==</span> <span class="num">2</span><span class="opt">) {</span>
        reg <span class="opt">=</span> SimdRegisterType<span class="opt">{</span>v<span class="opt">,</span> v<span class="opt">};</span>
    <span class="opt">}</span> <span class="kwa">else if</span> <span class="kwc">constexpr</span> <span class="opt">(</span>numbersInReg <span class="opt">==</span> <span class="num">4</span><span class="opt">) {</span>
        reg <span class="opt">=</span> SimdRegisterType<span class="opt">{</span>v<span class="opt">,</span> v<span class="opt">,</span> v<span class="opt">,</span> v<span class="opt">};</span>
    <span class="opt">}</span> <span class="kwa">else if</span> <span class="kwc">constexpr</span> <span class="opt">(</span>numbersInReg <span class="opt">==</span> <span class="num">8</span><span class="opt">) {</span>
        reg <span class="opt">=</span> SimdRegisterType<span class="opt">{</span>v<span class="opt">,</span> v<span class="opt">,</span> v<span class="opt">,</span> v<span class="opt">,</span> v<span class="opt">,</span> v<span class="opt">,</span> v<span class="opt">,</span> v<span class="opt">};</span>
    <span class="opt">}</span>
<span class="opt">}</span>
<span class="kwc">template</span><span class="opt">&lt;</span><span class="kwc">class</span> SimdUnion<span class="opt">&gt;</span>
<span class="kwb">void</span> <span class="kwd">setValue</span><span class="opt">(</span>SimdUnion<span class="opt">&amp;</span> simdUnion<span class="opt">,</span> typename <span class="kwc">SimdUnion</span><span class="opt">::</span>NumberType v<span class="opt">) {</span>
    <span class="kwa">using</span> SimdRegisterType <span class="opt">=</span> typename <span class="kwc">SimdUnion</span><span class="opt">::</span>SimdRegisterType<span class="opt">;</span>
    SimdRegisterType<span class="opt">*</span> vValues <span class="opt">=</span> simdUnion<span class="opt">.</span>reg<span class="opt">;</span>
    <span class="kwc">constexpr auto</span> numbersInReg <span class="opt">=</span> numberOfNumbersInRegister<span class="opt">&lt;</span>SimdUnion<span class="opt">&gt;();</span>
    <span class="kwa">for</span> <span class="opt">(</span><span class="kwc">std</span><span class="opt">::</span><span class="kwb">size_t</span> i<span class="opt">=</span><span class="num">0</span><span class="opt">;</span> i<span class="opt">&lt;</span>numberOfNumbers<span class="opt">&lt;</span>SimdUnion<span class="opt">&gt;();</span> i<span class="opt">+=</span>numbersInReg<span class="opt">) {</span>
        setValueInReg<span class="opt">&lt;</span>SimdUnion<span class="opt">&gt;(*</span>vValues<span class="opt">,</span> v<span class="opt">);</span>
        vValues<span class="opt">++;</span>
    <span class="opt">}</span>
<span class="opt">}</span>
<span class="slc">// Special method that reverses the order of numbers in one register. This</span>
<span class="slc">// helps for using SIMD functions to get bit masks already in the correct order</span>
<span class="slc">// needed for the portable bitmap.</span>
<span class="kwc">template</span><span class="opt">&lt;</span><span class="kwc">class</span> SimdUnion<span class="opt">,</span> <span class="kwc">class</span> Functor<span class="opt">&gt;</span>
<span class="kwb">void</span> <span class="kwd">setRealValuesReverseInReg</span><span class="opt">(</span>SimdUnion<span class="opt">&amp;</span> simdUnion<span class="opt">,</span> Functor f<span class="opt">) {</span>
    <span class="kwc">constexpr auto</span> numbersInReg <span class="opt">=</span> numberOfNumbersInRegister<span class="opt">&lt;</span>SimdUnion<span class="opt">&gt;();</span>
    <span class="kwc">std</span><span class="opt">::</span><span class="kwb">size_t</span> n<span class="opt">=</span><span class="num">0</span><span class="opt">;</span>
    <span class="kwa">for</span> <span class="opt">(</span><span class="kwc">std</span><span class="opt">::</span><span class="kwb">size_t</span> i<span class="opt">=</span><span class="num">0</span><span class="opt">;</span> i<span class="opt">&lt;</span>numberOfNumbers<span class="opt">&lt;</span>SimdUnion<span class="opt">&gt;();</span> i<span class="opt">+=</span>numbersInReg<span class="opt">) {</span>
        <span class="kwa">for</span> <span class="opt">(</span><span class="kwc">std</span><span class="opt">::</span><span class="kwb">size_t</span> j<span class="opt">=</span>numbersInReg<span class="opt">;</span> j<span class="opt">&gt;</span><span class="num">0</span><span class="opt">;</span> j<span class="opt">--) {</span>
            simdUnion<span class="opt">.</span>val<span class="opt">[</span>i<span class="opt">+</span>j<span class="opt">-</span><span class="num">1</span><span class="opt">] =</span> <span class="kwd">f</span><span class="opt">(</span>n<span class="opt">);</span>
            n<span class="opt">++;</span>
        <span class="opt">}</span>
    <span class="opt">}</span>
<span class="opt">}</span>

<span class="slc">// VectorizedComplex provides a convenient interface to deal with complex</span>
<span class="slc">// numbers and uses the power of SIMD for high execution speed.</span>
<span class="kwc">template</span> <span class="opt">&lt;</span><span class="kwc">class</span> SimdUnion<span class="opt">&gt;</span>
<span class="kwc">class</span> VectorizedComplex <span class="opt">{</span>
<span class="kwc">public</span><span class="opt">:</span>
    <span class="kwa">using</span> NumberType <span class="opt">=</span> typename <span class="kwc">SimdUnion</span><span class="opt">::</span>NumberType<span class="opt">;</span>
    <span class="kwa">using</span> SimdRegisterType <span class="opt">=</span> typename <span class="kwc">SimdUnion</span><span class="opt">::</span>SimdRegisterType<span class="opt">;</span>
    <span class="kwa">using</span> Size <span class="opt">=</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwb">size_t</span><span class="opt">;</span>

    <span class="kwd">VectorizedComplex</span><span class="opt">() =</span> <span class="kwa">default</span><span class="opt">;</span>
    <span class="kwd">VectorizedComplex</span><span class="opt">(</span><span class="kwb">const</span> VectorizedComplex<span class="opt">&amp;) =</span> <span class="kwa">default</span><span class="opt">;</span>
    VectorizedComplex<span class="opt">&amp;</span> <span class="kwc">operator</span><span class="opt">=(</span><span class="kwb">const</span> VectorizedComplex<span class="opt">&amp;) =</span> <span class="kwa">default</span><span class="opt">;</span>
    <span class="kwd">VectorizedComplex</span><span class="opt">(</span><span class="kwb">const</span> SimdUnion<span class="opt">&amp;</span> reals<span class="opt">,</span> NumberType commonImagValue<span class="opt">)</span>
    <span class="opt">:</span> <span class="kwd">_reals</span><span class="opt">(</span>reals<span class="opt">) {</span>
        <span class="kwd">setValue</span><span class="opt">(</span>_imags<span class="opt">,</span> commonImagValue<span class="opt">);</span>
    <span class="opt">}</span>
    VectorizedComplex<span class="opt">&amp;</span> <span class="kwd">squareAndAdd</span><span class="opt">(</span><span class="kwb">const</span> VectorizedComplex<span class="opt">&amp;</span> c<span class="opt">,</span>
            SimdUnion<span class="opt">&amp;</span> squaredAbs<span class="opt">) {</span>
        <span class="kwa">for</span> <span class="opt">(</span>Size i<span class="opt">=</span><span class="num">0</span><span class="opt">;</span> i<span class="opt">&lt;</span>numberOfRegisters<span class="opt">&lt;</span>SimdUnion<span class="opt">&gt;();</span> i<span class="opt">++) {</span>
            <span class="kwc">auto</span> realSquared <span class="opt">=</span> _reals<span class="opt">.</span>reg<span class="opt">[</span>i<span class="opt">] *</span> _reals<span class="opt">.</span>reg<span class="opt">[</span>i<span class="opt">];</span>
            <span class="kwc">auto</span> imagSquared <span class="opt">=</span> _imags<span class="opt">.</span>reg<span class="opt">[</span>i<span class="opt">] *</span> _imags<span class="opt">.</span>reg<span class="opt">[</span>i<span class="opt">];</span>
            <span class="kwc">auto</span> realTimesImag <span class="opt">=</span> _reals<span class="opt">.</span>reg<span class="opt">[</span>i<span class="opt">] *</span> _imags<span class="opt">.</span>reg<span class="opt">[</span>i<span class="opt">];</span>
            _reals<span class="opt">.</span>reg<span class="opt">[</span>i<span class="opt">] =</span> realSquared <span class="opt">-</span> imagSquared <span class="opt">+</span> c<span class="opt">.</span>_reals<span class="opt">.</span>reg<span class="opt">[</span>i<span class="opt">];</span>
            _imags<span class="opt">.</span>reg<span class="opt">[</span>i<span class="opt">] =</span> realTimesImag <span class="opt">+</span> realTimesImag <span class="opt">+</span> c<span class="opt">.</span>_imags<span class="opt">.</span>reg<span class="opt">[</span>i<span class="opt">];</span>
            squaredAbs<span class="opt">.</span>reg<span class="opt">[</span>i<span class="opt">] =</span> realSquared <span class="opt">+</span> imagSquared<span class="opt">;</span>
        <span class="opt">}</span>
        <span class="kwa">return</span> <span class="opt">*</span><span class="kwa">this</span><span class="opt">;</span>
    <span class="opt">}</span>
<span class="kwc">private</span><span class="opt">:</span>
    SimdUnion _reals<span class="opt">;</span>
    SimdUnion _imags<span class="opt">;</span>
<span class="opt">};</span>

<span class="slc">// The ComplexPlaneCalculator performs function f(c), with c as a</span>
<span class="slc">// VectorizedComplex and a byte as the return value. Due to its eightfold</span>
<span class="slc">// vectorization, each returned bit can return a Boolean value from the</span>
<span class="slc">// calculation f(c). The full byte is then written to the canvas. This is done</span>
<span class="slc">// until the whole bitmap is filled.</span>
<span class="kwc">template</span> <span class="opt">&lt;</span><span class="kwc">class</span> SimdUnion<span class="opt">,</span> <span class="kwc">class</span> Functor<span class="opt">&gt;</span>
<span class="kwc">class</span> ComplexPlaneCalculator <span class="opt">{</span>
<span class="kwc">public</span><span class="opt">:</span>
    <span class="kwa">using</span> VComplex <span class="opt">=</span> VectorizedComplex<span class="opt">&lt;</span>SimdUnion<span class="opt">&gt;;</span>
    <span class="kwa">using</span> NumberType <span class="opt">=</span> typename <span class="kwc">SimdUnion</span><span class="opt">::</span>NumberType<span class="opt">;</span>
    <span class="kwa">using</span> Line <span class="opt">=</span> typename <span class="kwc">PortableBinaryBitmap</span><span class="opt">::</span>Line<span class="opt">;</span>
    <span class="kwa">using</span> Size <span class="opt">=</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwb">size_t</span><span class="opt">;</span>

    <span class="kwd">ComplexPlaneCalculator</span><span class="opt">(</span><span class="kwb">const</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwb">complex</span><span class="opt">&lt;</span>NumberType<span class="opt">&gt;&amp;</span> cFirst<span class="opt">,</span>
            <span class="kwb">const</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwb">complex</span><span class="opt">&lt;</span>NumberType<span class="opt">&gt;&amp;</span> cLast<span class="opt">,</span>
            <span class="kwc">PortableBinaryBitmap</span><span class="opt">::</span>InterlacedCanvas<span class="opt">&amp;</span> canvas<span class="opt">,</span> Functor f<span class="opt">)</span>
    <span class="opt">:</span> <span class="kwd">_cFirst</span><span class="opt">(</span>cFirst<span class="opt">)</span>
    <span class="opt">,</span> <span class="kwd">_cLast</span><span class="opt">(</span>cLast<span class="opt">)</span>
    <span class="opt">,</span> <span class="kwd">_canvas</span><span class="opt">(</span>canvas<span class="opt">)</span>
    <span class="opt">,</span> <span class="kwd">_f</span><span class="opt">(</span>f<span class="opt">) {</span>
        <span class="kwa">static_assert</span><span class="opt">(</span>numberOfNumbers<span class="opt">&lt;</span>SimdUnion<span class="opt">&gt;() ==</span> <span class="kwc">Line</span><span class="opt">::</span><span class="kwd">pixelsPerWrite</span><span class="opt">());</span>
    <span class="opt">}</span>
    <span class="kwb">void</span> <span class="kwc">operator</span><span class="opt">()()</span> noexcept <span class="opt">{</span>
        <span class="kwb">const</span> NumberType realRange <span class="opt">=</span> _cLast<span class="opt">.</span><span class="kwd">real</span><span class="opt">() -</span> _cFirst<span class="opt">.</span><span class="kwd">real</span><span class="opt">();</span>
        <span class="kwb">const</span> NumberType imagRange <span class="opt">=</span> _cLast<span class="opt">.</span><span class="kwd">imag</span><span class="opt">() -</span> _cFirst<span class="opt">.</span><span class="kwd">imag</span><span class="opt">();</span>
        <span class="kwb">const</span> NumberType rasterReal <span class="opt">=</span> realRange <span class="opt">/</span> _canvas<span class="opt">.</span><span class="kwd">width</span><span class="opt">();</span>
        <span class="kwb">const</span> NumberType rasterImag <span class="opt">=</span> imagRange <span class="opt">/</span> _canvas<span class="opt">.</span><span class="kwd">height</span><span class="opt">();</span>
        <span class="kwc">std</span><span class="opt">::</span>vector<span class="opt">&lt;</span>SimdUnion<span class="opt">&gt;</span> cRealValues<span class="opt">;</span>
        cRealValues<span class="opt">.</span><span class="kwd">reserve</span><span class="opt">(</span>_canvas<span class="opt">.</span><span class="kwd">width</span><span class="opt">() /</span> <span class="kwc">Line</span><span class="opt">::</span><span class="kwd">pixelsPerWrite</span><span class="opt">());</span>
        <span class="kwa">for</span> <span class="opt">(</span>Size x<span class="opt">=</span><span class="num">0</span><span class="opt">;</span> x<span class="opt">&lt;</span>_canvas<span class="opt">.</span><span class="kwd">width</span><span class="opt">();</span> x<span class="opt">+=</span><span class="kwc">Line</span><span class="opt">::</span><span class="kwd">pixelsPerWrite</span><span class="opt">()) {</span>
            SimdUnion cReals<span class="opt">;</span>
            <span class="kwd">setRealValuesReverseInReg</span><span class="opt">(</span>cReals<span class="opt">, [&amp;](</span>Size i<span class="opt">){</span>
                <span class="kwa">return</span> _cFirst<span class="opt">.</span><span class="kwd">real</span><span class="opt">() + (</span>x<span class="opt">+</span>i<span class="opt">)*</span>rasterReal<span class="opt">;</span>
            <span class="opt">});</span>
            cRealValues<span class="opt">.</span><span class="kwd">push_back</span><span class="opt">(</span>cReals<span class="opt">);</span>
        <span class="opt">}</span>
        <span class="kwa">for</span> <span class="opt">(</span>Line<span class="opt">&amp;</span> line <span class="opt">:</span> _canvas<span class="opt">) {</span>
            <span class="kwb">char</span><span class="opt">*</span> nextPixels <span class="opt">=</span> line<span class="opt">.</span>data<span class="opt">;</span>
            <span class="kwb">char</span> lastPixels <span class="opt">=</span> <span class="num">0x00</span><span class="opt">;</span>
            <span class="kwb">const</span> NumberType cImagValue <span class="opt">=</span> _cFirst<span class="opt">.</span><span class="kwd">imag</span><span class="opt">() +</span> line<span class="opt">.</span>y<span class="opt">*</span>rasterImag<span class="opt">;</span>
            <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">const</span> SimdUnion<span class="opt">&amp;</span> cReals <span class="opt">:</span> cRealValues<span class="opt">) {</span>
                <span class="kwb">const</span> VComplex <span class="kwd">c</span><span class="opt">(</span>cReals<span class="opt">,</span> cImagValue<span class="opt">);</span>
                <span class="opt">*</span>nextPixels <span class="opt">=</span> <span class="kwd">_f</span><span class="opt">(</span>c<span class="opt">,</span> lastPixels<span class="opt">);</span>
                lastPixels <span class="opt">= *</span>nextPixels<span class="opt">;</span>
                nextPixels<span class="opt">++;</span>
            <span class="opt">}</span>
        <span class="opt">}</span>
    <span class="opt">}</span>
<span class="kwc">private</span><span class="opt">:</span>
    <span class="kwc">std</span><span class="opt">::</span><span class="kwb">complex</span><span class="opt">&lt;</span>NumberType<span class="opt">&gt;</span> _cFirst<span class="opt">;</span>
    <span class="kwc">std</span><span class="opt">::</span><span class="kwb">complex</span><span class="opt">&lt;</span>NumberType<span class="opt">&gt;</span> _cLast<span class="opt">;</span>
    <span class="kwc">PortableBinaryBitmap</span><span class="opt">::</span>InterlacedCanvas _canvas<span class="opt">;</span>
    Functor _f<span class="opt">;</span>
<span class="opt">};</span>

<span class="slc">// Functor calculating a Mandelbrot iteration for a VectorizedComplex. This</span>
<span class="slc">// means that for eight complex numbers the Mandelbrot calculation is</span>
<span class="slc">// (potentially) executed in parallel. The result is a byte that contains a 1</span>
<span class="slc">// for each bit if the corresponding complex number is in the Mandelbrot set,</span>
<span class="slc">// and a 0 if it is not.</span>
<span class="kwc">template</span> <span class="opt">&lt;</span><span class="kwc">class</span> SimdUnion<span class="opt">&gt;</span>
<span class="kwc">class</span> MandelbrotFunction <span class="opt">{</span>
<span class="kwc">public</span><span class="opt">:</span>
    <span class="kwa">using</span> VComplex <span class="opt">=</span> VectorizedComplex<span class="opt">&lt;</span>SimdUnion<span class="opt">&gt;;</span>
    <span class="kwa">using</span> SimdRegisterType <span class="opt">=</span> typename <span class="kwc">SimdUnion</span><span class="opt">::</span>SimdRegisterType<span class="opt">;</span>
    <span class="kwa">using</span> NumberType <span class="opt">=</span> typename <span class="kwc">SimdUnion</span><span class="opt">::</span>NumberType<span class="opt">;</span>
    <span class="kwa">using</span> Size <span class="opt">=</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwb">size_t</span><span class="opt">;</span>
    <span class="kwc">constexpr</span> <span class="kwb">static</span> Size ITERATIONS_WITHOUT_CHECK <span class="opt">=</span> <span class="num">5</span><span class="opt">;</span>
    <span class="kwc">constexpr</span> <span class="kwb">static char</span> NONE_IN_MANDELBROT_SET <span class="opt">=</span> <span class="num">0x00</span><span class="opt">;</span>

    <span class="kwd">MandelbrotFunction</span><span class="opt">(</span>Size maxIterations<span class="opt">,</span> NumberType pointOfNoReturn <span class="opt">=</span> <span class="num">2.0</span><span class="opt">)</span>
    <span class="opt">:</span> <span class="kwd">_maxOuterIterations</span><span class="opt">(</span>maxIterations <span class="opt">/</span> ITERATIONS_WITHOUT_CHECK <span class="opt">-</span> <span class="num">2</span><span class="opt">) {</span>
        setValueInReg<span class="opt">&lt;</span>SimdUnion<span class="opt">&gt;(</span>_squaredPointOfNoReturn<span class="opt">,</span>
                pointOfNoReturn <span class="opt">*</span> pointOfNoReturn<span class="opt">);</span>
    <span class="opt">}</span>
    <span class="kwc">inline</span> <span class="kwb">static void</span> <span class="kwd">doMandelbrotIterations</span><span class="opt">(</span>VComplex<span class="opt">&amp;</span> z<span class="opt">,</span> <span class="kwb">const</span> VComplex<span class="opt">&amp;</span> c<span class="opt">,</span>
            SimdUnion<span class="opt">&amp;</span> squaredAbs<span class="opt">) {</span>
        <span class="kwa">for</span> <span class="opt">(</span>Size j<span class="opt">=</span><span class="num">0</span><span class="opt">;</span> j<span class="opt">&lt;</span>ITERATIONS_WITHOUT_CHECK<span class="opt">;</span> j<span class="opt">++) {</span>
            z<span class="opt">.</span><span class="kwd">squareAndAdd</span><span class="opt">(</span>c<span class="opt">,</span> squaredAbs<span class="opt">);</span>
        <span class="opt">}</span>
    <span class="opt">}</span>
    <span class="kwb">char</span> <span class="kwc">operator</span><span class="opt">()(</span><span class="kwb">const</span> VComplex<span class="opt">&amp;</span> c<span class="opt">,</span> <span class="kwb">char</span> lastPixels<span class="opt">)</span> <span class="kwb">const</span> <span class="opt">{</span>
        VComplex z <span class="opt">=</span> c<span class="opt">;</span>
        SimdUnion squaredAbs<span class="opt">;</span>
        <span class="kwa">if</span> <span class="opt">(</span>lastPixels <span class="opt">==</span> NONE_IN_MANDELBROT_SET<span class="opt">) {</span>
            <span class="kwa">for</span> <span class="opt">(</span>Size i<span class="opt">=</span><span class="num">0</span><span class="opt">;</span> i<span class="opt">&lt;</span>_maxOuterIterations<span class="opt">;</span> i<span class="opt">++) {</span>
                <span class="kwd">doMandelbrotIterations</span><span class="opt">(</span>z<span class="opt">,</span> c<span class="opt">,</span> squaredAbs<span class="opt">);</span>
                <span class="kwa">if</span> <span class="opt">(</span>squaredAbs <span class="opt">&gt;</span> _squaredPointOfNoReturn<span class="opt">) {</span>
                    <span class="kwa">return</span> NONE_IN_MANDELBROT_SET<span class="opt">;</span>
                <span class="opt">}</span>
            <span class="opt">}</span>
        <span class="opt">}</span> <span class="kwa">else</span> <span class="opt">{</span>
            <span class="kwa">for</span> <span class="opt">(</span>Size i<span class="opt">=</span><span class="num">0</span><span class="opt">;</span> i<span class="opt">&lt;</span>_maxOuterIterations<span class="opt">;</span> i<span class="opt">++) {</span>
                <span class="kwd">doMandelbrotIterations</span><span class="opt">(</span>z<span class="opt">,</span> c<span class="opt">,</span> squaredAbs<span class="opt">);</span>
            <span class="opt">}</span>
        <span class="opt">}</span>
        <span class="kwd">doMandelbrotIterations</span><span class="opt">(</span>z<span class="opt">,</span> c<span class="opt">,</span> squaredAbs<span class="opt">);</span>
        <span class="kwd">doMandelbrotIterations</span><span class="opt">(</span>z<span class="opt">,</span> c<span class="opt">,</span> squaredAbs<span class="opt">);</span>
        <span class="kwa">return</span> squaredAbs<span class="opt">.</span><span class="kwd">lteToPixels</span><span class="opt">(</span>_squaredPointOfNoReturn<span class="opt">);</span>
    <span class="opt">}</span>
<span class="kwc">private</span><span class="opt">:</span>
    Size _maxOuterIterations<span class="opt">;</span>
    SimdRegisterType _squaredPointOfNoReturn<span class="opt">;</span>
<span class="opt">};</span>

<span class="ppc">#if defined(__AVX512BW__)</span>
<span class="kwa">using</span> SystemSimdUnion <span class="opt">=</span> Simd512DUnion<span class="opt">;</span>
<span class="ppc">#elif defined __AVX__</span>
<span class="kwa">using</span> SystemSimdUnion <span class="opt">=</span> Simd256DUnion<span class="opt">;</span>
<span class="ppc">#elif defined __SSE__</span>
<span class="kwa">using</span> SystemSimdUnion <span class="opt">=</span> Simd128DUnion<span class="opt">;</span>
<span class="ppc">#else</span>
<span class="kwa">using</span> SystemSimdUnion <span class="opt">=</span> NoSimdUnion<span class="opt">;</span>
<span class="ppc">#endif</span>

<span class="opt">}</span> <span class="slc">// end namespace</span>

<span class="kwb">int</span> <span class="kwd">main</span><span class="opt">(</span><span class="kwb">int</span> argc<span class="opt">,</span> <span class="kwb">char</span><span class="opt">**</span> argv<span class="opt">) {</span>
    <span class="kwa">using</span> NumberType <span class="opt">=</span> <span class="kwc">SystemSimdUnion</span><span class="opt">::</span>NumberType<span class="opt">;</span>
    <span class="kwa">using</span> ComplexNumber <span class="opt">=</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwb">complex</span><span class="opt">&lt;</span>NumberType<span class="opt">&gt;;</span>
    <span class="kwa">using</span> MandelbrotCalculator <span class="opt">=</span> ComplexPlaneCalculator<span class="opt">&lt;</span>SystemSimdUnion<span class="opt">,</span>
            MandelbrotFunction<span class="opt">&lt;</span>SystemSimdUnion<span class="opt">&gt;&gt;;</span>
    <span class="kwc">std</span><span class="opt">::</span><span class="kwb">size_t</span> n <span class="opt">=</span> <span class="num">16000</span><span class="opt">;</span>
    <span class="kwa">if</span> <span class="opt">(</span>argc<span class="opt">&gt;=</span><span class="num">2</span><span class="opt">) {</span>
        n <span class="opt">=</span> <span class="kwd">atoi</span><span class="opt">(</span>argv<span class="opt">[</span><span class="num">1</span><span class="opt">]);</span>
    <span class="opt">}</span>
    <span class="kwb">const</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwb">size_t</span> maxIterations <span class="opt">=</span> <span class="num">50</span><span class="opt">;</span>
    PortableBinaryBitmap <span class="kwd">pbm</span><span class="opt">(</span><span class="kwc">std</span><span class="opt">::</span>cout<span class="opt">,</span> n<span class="opt">,</span> n<span class="opt">);</span>
    <span class="kwc">auto</span> canvasVector <span class="opt">=</span> pbm<span class="opt">.</span><span class="kwd">provideInterlacedCanvas</span><span class="opt">(</span>numberOfCpuCores<span class="opt">);</span>
    <span class="kwc">std</span><span class="opt">::</span>vector<span class="opt">&lt;</span><span class="kwc">std</span><span class="opt">::</span>thread<span class="opt">&gt;</span> threads<span class="opt">;</span>
    <span class="kwa">for</span> <span class="opt">(</span><span class="kwc">auto</span><span class="opt">&amp;</span> canvas <span class="opt">:</span> canvasVector<span class="opt">) {</span>
        threads<span class="opt">.</span><span class="kwd">emplace_back</span><span class="opt">(</span><span class="kwd">MandelbrotCalculator</span> <span class="opt">(</span><span class="kwd">ComplexNumber</span><span class="opt">(-</span><span class="num">1.5</span><span class="opt">, -</span><span class="num">1.0</span><span class="opt">),</span>
                <span class="kwd">ComplexNumber</span><span class="opt">(</span><span class="num">0.5</span><span class="opt">,</span> <span class="num">1.0</span><span class="opt">),</span> canvas<span class="opt">,</span>
                MandelbrotFunction<span class="opt">&lt;</span>SystemSimdUnion<span class="opt">&gt; (</span>maxIterations<span class="opt">)));</span>
    <span class="opt">}</span>
    <span class="kwa">for</span> <span class="opt">(</span><span class="kwc">auto</span><span class="opt">&amp;</span> t <span class="opt">:</span> threads<span class="opt">) {</span>
        t<span class="opt">.</span><span class="kwd">join</span><span class="opt">();</span>
    <span class="opt">}</span>
    <span class="kwa">return</span> <span class="num">0</span><span class="opt">;</span>
<span class="opt">}</span>
    </pre>
  </section>
  <section>
    <div>
      <h2 id="log">notes, command-line, and program output</h2>
    </div>
    <pre>
NOTES:
64-bit Ubuntu quad core
g++ (Ubuntu 9.3.0-10ubuntu2) 9.3.0


Thu, 18 Jun 2020 19:57:37 GMT

MAKE:
/usr/bin/g++ -c -pipe -O3 -fomit-frame-pointer -march=core2  -std=c++17 -mno-fma mandelbrot.gpp-0.c++ -o mandelbrot.gpp-0.c++.o &amp;&amp;  \
        /usr/bin/g++ mandelbrot.gpp-0.c++.o -o mandelbrot.gpp-0.gpp_run -pthread 
rm mandelbrot.gpp-0.c++

6.69s to complete and log all make actions

COMMAND LINE:
./mandelbrot.gpp-0.gpp_run 16000

(BINARY) PROGRAM OUTPUT NOT SHOWN
    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="https://salsa.debian.org/benchmarksgame-team/benchmarksgame/blob/master/CONTRIBUTING.md#contribute-source-code-for-measurement"><span>Contribute your own program</span></a>
      <li><a href="../../license.html"><span>3-Clause BSD License</span></a>
    </ul>
  </nav>
</footer>

