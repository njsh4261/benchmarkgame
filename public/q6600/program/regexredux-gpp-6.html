<!DOCTYPE html>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="robots" content="noindex,follow,noarchive">

<title>regex-redux C++ g++&nbsp;#6 program | Q6600 Benchmarks Game </title>
<link href="../program.css" rel = "stylesheet" type = "text/css" >
<link rel="shortcut icon" href="../favicon.ico">
<header>
  <h3><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/q6600/">The&nbsp;Q6600<br>Benchmarks&nbsp;Game</a></h3>
</header>
<article>
  <div>
    <h1>regex-redux C++ g++&nbsp;#6 program</h1>
    <aside>
      <p><a href="../description/regexredux.html#regexredux">description</a>
    </aside>
  </div>
  <section>
    <div>
      <h2>source code</h2>
    </div>
    <pre>
<span class="slc">// The Computer Language Benchmarks Game</span>
<span class="slc">// https://salsa.debian.org/benchmarksgame-team/benchmarksgame/</span>
<span class="slc">//</span>
<span class="slc">// contributed by Markus Lenger</span>
<span class="slc">//</span>
<span class="slc">// This implementation of regex-redux uses the regular expression library PCRE2</span>
<span class="slc">// PCRE2 allows to compile regular expressions into machine code at runtime</span>
<span class="slc">// (JIT compile) which makes it extremely fast.</span>
<span class="slc">//</span>
<span class="slc">// See https://www.pcre.org/current/doc/html/index.html for more info on PCRE2.</span>
<span class="slc">// The code is heavily commented to enhance readability for people who don&apos;t</span>
<span class="slc">// know C++. For those who do the comments might be annoying ;)</span>

<span class="ppc">#include &lt;algorithm&gt;</span>
<span class="ppc">#include &lt;boost/noncopyable.hpp&gt;</span>
<span class="ppc">#include &lt;fstream&gt;</span>
<span class="ppc">#include &lt;future&gt;</span>
<span class="ppc">#include &lt;iostream&gt;</span>
<span class="ppc">#include &lt;iterator&gt;</span>
<span class="ppc">#include &lt;memory&gt;</span>
<span class="ppc">#include &lt;sstream&gt;</span>
<span class="ppc">#include &lt;vector&gt;</span>
<span class="ppc">#define PCRE2_CODE_UNIT_WIDTH 8</span>
<span class="ppc">#include &lt;pcre2.h&gt;</span>

<span class="slc">// Cast std::string to PCRE2 buffer</span>
<span class="kwc">inline</span> PCRE2_UCHAR8<span class="opt">*</span> <span class="kwd">pcre2_buffer_cast</span><span class="opt">(</span><span class="kwc">std</span><span class="opt">::</span>string<span class="opt">&amp;</span> str<span class="opt">)</span>
<span class="opt">{</span>
    <span class="kwa">return reinterpret_cast</span><span class="opt">&lt;</span>PCRE2_UCHAR8<span class="opt">*&gt;(</span>str<span class="opt">.</span><span class="kwd">data</span><span class="opt">());</span>
<span class="opt">}</span>

<span class="slc">// Cast std::string to PCRE2 immutable string</span>
<span class="kwc">inline</span> PCRE2_SPTR8 <span class="kwd">pcre2_string_cast</span><span class="opt">(</span><span class="kwb">const</span> <span class="kwc">std</span><span class="opt">::</span>string<span class="opt">&amp;</span> str<span class="opt">)</span>
<span class="opt">{</span>
    <span class="kwa">return reinterpret_cast</span><span class="opt">&lt;</span>PCRE2_SPTR8<span class="opt">&gt;(</span>str<span class="opt">.</span><span class="kwd">c_str</span><span class="opt">());</span>
<span class="opt">}</span>

<span class="com">/*</span>
<span class="com"> * This class wraps JIT-compiled PCRE2 regular expressions and data-structures</span>
<span class="com"> * needed for matching the regular expressions against strings. The class is</span>
<span class="com"> * derived from boost::noncopyable to prevent accidental copying.</span>
<span class="com"> */</span>
<span class="kwc">class</span> regex <span class="opt">:</span> <span class="kwc">private boost</span><span class="opt">::</span>noncopyable
<span class="opt">{</span>
<span class="kwc">public</span><span class="opt">:</span>
    <span class="kwc">inline explicit</span> <span class="kwd">regex</span><span class="opt">(</span><span class="kwb">const</span> <span class="kwc">std</span><span class="opt">::</span>string<span class="opt">&amp;</span> regex_str<span class="opt">)</span>
    <span class="opt">{</span>
        <span class="kwd">compile_regex</span><span class="opt">(</span>regex_str<span class="opt">);</span>
        <span class="kwd">allocate_match_data</span><span class="opt">();</span>
    <span class="opt">}</span>

    <span class="kwc">inline</span> <span class="opt">~</span><span class="kwd">regex</span><span class="opt">()</span>
    <span class="opt">{</span>
        <span class="kwd">pcre2_code_free</span><span class="opt">(</span>_code<span class="opt">);</span>
        <span class="kwd">pcre2_match_data_free</span><span class="opt">(</span>_match_data<span class="opt">);</span>
        <span class="kwd">pcre2_match_context_free</span><span class="opt">(</span>_match_context<span class="opt">);</span>
        <span class="kwd">pcre2_jit_stack_free</span><span class="opt">(</span>_jit_stack<span class="opt">);</span>
    <span class="opt">}</span>

    <span class="slc">// Count matches of this regex within subject</span>
    <span class="kwc">inline std</span><span class="opt">::</span><span class="kwb">size_t</span> <span class="kwd">count_matches</span><span class="opt">(</span><span class="kwb">const</span> <span class="kwc">std</span><span class="opt">::</span>string<span class="opt">&amp;</span> subject<span class="opt">)</span> <span class="kwb">const</span>
    <span class="opt">{</span>
        <span class="slc">// Definition of a functor for counting occurrences</span>
        <span class="kwb">struct</span> count_functor
        <span class="opt">{</span>
            <span class="kwc">std</span><span class="opt">::</span><span class="kwb">size_t</span> match_cnt <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
            <span class="com">/* This method (operator) will be called for every match in the</span>
<span class="com">             subject */</span>
            <span class="kwc">inline</span> <span class="kwb">void</span> <span class="kwc">operator</span><span class="opt">()(</span>PCRE2_SPTR subject<span class="opt">,</span>
                PCRE2_SIZE match_begin<span class="opt">,</span>
                PCRE2_SIZE match_end<span class="opt">)</span>
            <span class="opt">{</span>
                <span class="slc">// We ignore these arguments</span>
                <span class="kwc">std</span><span class="opt">::</span>ignore <span class="opt">=</span> subject<span class="opt">;</span>
                <span class="kwc">std</span><span class="opt">::</span>ignore <span class="opt">=</span> match_begin<span class="opt">;</span>
                <span class="kwc">std</span><span class="opt">::</span>ignore <span class="opt">=</span> match_end<span class="opt">;</span>
                <span class="slc">// And just increase the match_cnt</span>
                match_cnt<span class="opt">++;</span>
            <span class="opt">}</span>
        <span class="opt">};</span>
        count_functor func<span class="opt">;</span>
        <span class="kwb">const</span> PCRE2_SPTR subject_begin <span class="opt">=</span> <span class="kwd">pcre2_string_cast</span><span class="opt">(</span>subject<span class="opt">);</span>
        <span class="kwb">const</span> PCRE2_SPTR subject_end <span class="opt">=</span> subject_begin <span class="opt">+</span> subject<span class="opt">.</span><span class="kwd">size</span><span class="opt">();</span>
        <span class="slc">// Here func.operator() is called for every match</span>
        <span class="kwd">for_each_match</span><span class="opt">(</span>subject_begin<span class="opt">,</span> subject_end<span class="opt">,</span> func<span class="opt">);</span>
        <span class="kwa">return</span> func<span class="opt">.</span>match_cnt<span class="opt">;</span>
    <span class="opt">}</span>

    <span class="com">/* Replace all matches of this regex between &quot;subject_begin&quot; and</span>
<span class="com">      &quot;subject_end&quot; with &quot;replacement&quot; and store the result in the</span>
<span class="com">      result_buffer */</span>
    <span class="kwc">inline</span> PCRE2_SIZE <span class="kwd">replace_all</span><span class="opt">(</span><span class="kwb">const</span> <span class="kwc">std</span><span class="opt">::</span>string<span class="opt">&amp;</span> replacement<span class="opt">,</span>
        <span class="kwb">const</span> PCRE2_SPTR8 subject_begin<span class="opt">,</span>
        <span class="kwb">const</span> PCRE2_SPTR8 subject_end<span class="opt">,</span>
        PCRE2_UCHAR<span class="opt">*</span> <span class="kwb">const</span> result_buffer_begin<span class="opt">,</span>
        PCRE2_UCHAR<span class="opt">*</span> <span class="kwb">const</span> result_buffer_end<span class="opt">)</span> <span class="kwb">const</span>
    <span class="opt">{</span>
        <span class="slc">// Definition of a functor for replacing matches with strings</span>
        <span class="kwb">struct</span> replace_functor
        <span class="opt">{</span>
            PCRE2_UCHAR<span class="opt">*</span> _result_buffer_ptr<span class="opt">;</span>
            PCRE2_UCHAR<span class="opt">*</span> <span class="kwb">const</span> _result_buffer_end<span class="opt">;</span>
            <span class="kwb">const</span> <span class="kwc">std</span><span class="opt">::</span>string<span class="opt">&amp;</span> _replacement<span class="opt">;</span>
            PCRE2_SIZE _replacement_size<span class="opt">;</span>

            <span class="kwc">inline</span> <span class="kwd">replace_functor</span><span class="opt">(</span>PCRE2_UCHAR<span class="opt">*</span> <span class="kwb">const</span> result_buffer_begin<span class="opt">,</span>
                PCRE2_UCHAR<span class="opt">*</span> <span class="kwb">const</span> result_buffer_end<span class="opt">,</span>
                <span class="kwb">const</span> <span class="kwc">std</span><span class="opt">::</span>string<span class="opt">&amp;</span> replacement<span class="opt">)</span>
                <span class="opt">:</span> <span class="kwd">_result_buffer_ptr</span><span class="opt">(</span>result_buffer_begin<span class="opt">)</span>
                <span class="opt">,</span> <span class="kwd">_result_buffer_end</span><span class="opt">(</span>result_buffer_end<span class="opt">)</span>
                <span class="opt">,</span> <span class="kwd">_replacement</span><span class="opt">(</span>replacement<span class="opt">)</span>
                <span class="opt">,</span> <span class="kwd">_replacement_size</span><span class="opt">(</span>replacement<span class="opt">.</span><span class="kwd">size</span><span class="opt">())</span>
            <span class="opt">{</span>
            <span class="opt">}</span>

            <span class="slc">// This operator will be called for every match</span>
            <span class="kwc">inline</span> <span class="kwb">void</span> <span class="kwc">operator</span><span class="opt">()(</span><span class="kwb">const</span> PCRE2_SPTR subject_ptr<span class="opt">,</span>
                <span class="kwb">const</span> PCRE2_SIZE match_begin<span class="opt">,</span>
                <span class="kwb">const</span> PCRE2_SIZE match_end<span class="opt">)</span>
            <span class="opt">{</span>
                PCRE2_UCHAR<span class="opt">*</span> <span class="kwb">const</span> next_result_buffer
                    <span class="opt">=</span> _result_buffer_ptr <span class="opt">+</span> match_begin <span class="opt">+</span> _replacement_size<span class="opt">;</span>
                <span class="kwa">if</span> <span class="opt">(</span>next_result_buffer <span class="opt">&gt;</span> _result_buffer_end<span class="opt">)</span>
                <span class="opt">{</span>
                    <span class="kwa">throw</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwd">runtime_error</span><span class="opt">(</span><span class="str">&quot;Result buffer too small&quot;</span><span class="opt">);</span>
                <span class="opt">}</span>
                <span class="slc">// copy portions that did no match</span>
                <span class="kwc">std</span><span class="opt">::</span><span class="kwd">copy</span><span class="opt">(</span>
                    subject_ptr<span class="opt">,</span> subject_ptr <span class="opt">+</span> match_begin<span class="opt">,</span> _result_buffer_ptr<span class="opt">);</span>
                _result_buffer_ptr <span class="opt">+=</span> match_begin<span class="opt">;</span>
                <span class="slc">// paste replacement string</span>
                <span class="kwc">std</span><span class="opt">::</span><span class="kwd">copy</span><span class="opt">(</span>_replacement<span class="opt">.</span><span class="kwd">begin</span><span class="opt">(),</span> _replacement<span class="opt">.</span><span class="kwd">end</span><span class="opt">(),</span>
                    _result_buffer_ptr<span class="opt">);</span>
                _result_buffer_ptr <span class="opt">=</span> next_result_buffer<span class="opt">;</span>
            <span class="opt">}</span>

            <span class="slc">// Copy characters into the result buffer</span>
            <span class="kwc">inline</span> PCRE2_UCHAR<span class="opt">*</span> <span class="kwd">copy_into_result_buffer</span><span class="opt">(</span>
                <span class="kwb">const</span> PCRE2_SPTR begin<span class="opt">,</span> <span class="kwb">const</span> PCRE2_SPTR end<span class="opt">)</span>
            <span class="opt">{</span>
                <span class="slc">// Copy remainder</span>
                <span class="kwa">if</span> <span class="opt">(</span>begin <span class="opt">&gt;=</span> end<span class="opt">)</span>
                    <span class="kwa">return</span> _result_buffer_ptr<span class="opt">;</span>
                <span class="kwb">const</span> PCRE2_SIZE size <span class="opt">=</span> end <span class="opt">-</span> begin<span class="opt">;</span>
                <span class="kwa">if</span> <span class="opt">(</span>_result_buffer_ptr <span class="opt">+</span> size <span class="opt">&gt;</span> _result_buffer_end<span class="opt">)</span>
                <span class="opt">{</span>
                    <span class="kwa">throw</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwd">runtime_error</span><span class="opt">(</span><span class="str">&quot;Result buffer too small&quot;</span><span class="opt">);</span>
                <span class="opt">}</span>
                <span class="kwc">std</span><span class="opt">::</span><span class="kwd">copy</span><span class="opt">(</span>begin<span class="opt">,</span> end<span class="opt">,</span> _result_buffer_ptr<span class="opt">);</span>
                _result_buffer_ptr <span class="opt">+=</span> size<span class="opt">;</span>
                <span class="kwa">return</span> _result_buffer_ptr<span class="opt">;</span>
            <span class="opt">}</span>
        <span class="opt">};</span>

        <span class="slc">// Create an instance of the replace_functor</span>
        replace_functor <span class="kwd">func</span><span class="opt">(</span>
            result_buffer_begin<span class="opt">,</span> result_buffer_end<span class="opt">,</span> replacement<span class="opt">);</span>
        <span class="com">/* Apply the func.operator() on every match. subject_ptr points to the</span>
<span class="com">         * location just after the last match</span>
<span class="com">         */</span>
        PCRE2_SPTR subject_ptr
            <span class="opt">=</span> <span class="kwd">for_each_match</span><span class="opt">(</span>subject_begin<span class="opt">,</span> subject_end<span class="opt">,</span> func<span class="opt">);</span>
        <span class="slc">// Copy remainder from subject to result</span>
        PCRE2_UCHAR<span class="opt">*</span> result_buffer_ptr
            <span class="opt">=</span> func<span class="opt">.</span><span class="kwd">copy_into_result_buffer</span><span class="opt">(</span>subject_ptr<span class="opt">,</span> subject_end<span class="opt">);</span>
        <span class="slc">// Return the size of the result</span>
        <span class="kwa">return</span> result_buffer_ptr <span class="opt">-</span> result_buffer_begin<span class="opt">;</span>
    <span class="opt">}</span>

    <span class="kwc">inline std</span><span class="opt">::</span>string <span class="kwd">replace_all</span><span class="opt">(</span>
        <span class="kwb">const</span> <span class="kwc">std</span><span class="opt">::</span>string<span class="opt">&amp;</span> replacement<span class="opt">,</span> <span class="kwb">const</span> <span class="kwc">std</span><span class="opt">::</span>string<span class="opt">&amp;</span> subject<span class="opt">)</span> <span class="kwb">const</span>
    <span class="opt">{</span>
        <span class="kwc">std</span><span class="opt">::</span>string result<span class="opt">;</span>
        result<span class="opt">.</span><span class="kwd">resize</span><span class="opt">(</span>subject<span class="opt">.</span><span class="kwd">size</span><span class="opt">());</span>
        PCRE2_UCHAR<span class="opt">*</span> buffer_begin <span class="opt">=</span> <span class="kwd">pcre2_buffer_cast</span><span class="opt">(</span>result<span class="opt">);</span>
        PCRE2_SPTR8 pcre2_subject <span class="opt">=</span> <span class="kwd">pcre2_string_cast</span><span class="opt">(</span>subject<span class="opt">);</span>
        <span class="kwc">auto</span> result_size <span class="opt">=</span> <span class="kwd">replace_all</span><span class="opt">(</span>replacement<span class="opt">,</span> pcre2_subject<span class="opt">,</span>
            pcre2_subject <span class="opt">+</span> subject<span class="opt">.</span><span class="kwd">size</span><span class="opt">(),</span> <span class="kwd">pcre2_buffer_cast</span><span class="opt">(</span>result<span class="opt">),</span>
            buffer_begin <span class="opt">+</span> result<span class="opt">.</span><span class="kwd">size</span><span class="opt">());</span>

        result<span class="opt">.</span><span class="kwd">resize</span><span class="opt">(</span>result_size<span class="opt">);</span>
        <span class="kwa">return</span> result<span class="opt">;</span>
    <span class="opt">}</span>

<span class="kwc">private</span><span class="opt">:</span>
    <span class="slc">// Higher order function that allows application of functors to matches</span>
    <span class="kwc">template</span> <span class="opt">&lt;</span>typename FUNCTOR<span class="opt">&gt;</span>
    <span class="kwc">inline</span> PCRE2_SPTR8 <span class="kwd">for_each_match</span><span class="opt">(</span>
        PCRE2_SPTR subject_begin<span class="opt">,</span> PCRE2_SPTR subject_end<span class="opt">,</span> FUNCTOR<span class="opt">&amp;</span> action<span class="opt">)</span> <span class="kwb">const</span>
    <span class="opt">{</span>
        PCRE2_SPTR subject_ptr <span class="opt">=</span> subject_begin<span class="opt">;</span>
        <span class="kwb">int</span> status <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
        <span class="kwc">auto</span> ovector <span class="opt">=</span> <span class="kwd">pcre2_get_ovector_pointer</span><span class="opt">(</span>_match_data<span class="opt">);</span>
        <span class="slc">// offset of begin of match will always be stored in this array-element</span>
        PCRE2_SIZE<span class="opt">&amp;</span> begin_offset <span class="opt">=</span> ovector<span class="opt">[</span><span class="num">0</span><span class="opt">];</span>
        <span class="slc">// offset of end of match will always be stored in this array-element</span>
        PCRE2_SIZE<span class="opt">&amp;</span> end_offset <span class="opt">=</span> ovector<span class="opt">[</span><span class="num">1</span><span class="opt">];</span>
        <span class="kwa">while</span> <span class="opt">(</span>subject_ptr <span class="opt">&lt;</span> subject_end
            <span class="opt">&amp;&amp; (</span>status <span class="opt">=</span> <span class="kwd">pcre2_jit_match</span><span class="opt">(</span>_code<span class="opt">,</span> <span class="slc">// JIT compiled regex</span>
                    subject_ptr<span class="opt">,</span>
                    subject_end <span class="opt">-</span> subject_ptr<span class="opt">,</span> <span class="slc">// Size of subject</span>
                    <span class="num">0</span><span class="opt">,</span> <span class="slc">// Offset into subject</span>
                    <span class="num">0</span><span class="opt">,</span> <span class="slc">// Flags</span>
                    _match_data<span class="opt">,</span> <span class="slc">// Match info is stored here</span>
                    <span class="kwc">nullptr</span> <span class="slc">// Match context (none in our case)</span>
                    <span class="opt">))</span>
                <span class="opt">&gt;</span> <span class="num">0</span><span class="opt">)</span>
        <span class="opt">{</span>
            <span class="slc">// Call the functor</span>
            <span class="kwd">action</span><span class="opt">(</span>subject_ptr<span class="opt">,</span> begin_offset<span class="opt">,</span> end_offset<span class="opt">);</span>
            subject_ptr <span class="opt">+=</span> end_offset<span class="opt">;</span>
        <span class="opt">}</span>
        <span class="kwd">require_status_good</span><span class="opt">(</span>status<span class="opt">);</span>
        <span class="kwa">return</span> subject_ptr<span class="opt">;</span>
    <span class="opt">}</span>

    <span class="kwc">inline</span> <span class="kwb">void</span> <span class="kwd">compile_regex</span><span class="opt">(</span><span class="kwb">const</span> <span class="kwc">std</span><span class="opt">::</span>string<span class="opt">&amp;</span> regex_str<span class="opt">)</span>
    <span class="opt">{</span>
        PCRE2_SIZE error_offset<span class="opt">;</span>
        <span class="kwb">int</span> error_number<span class="opt">;</span>
        <span class="slc">// Parse and compile regular expression into PCRE2 representation</span>
        _code <span class="opt">= (</span><span class="kwd">pcre2_compile</span><span class="opt">(</span><span class="kwd">pcre2_string_cast</span><span class="opt">(</span>regex_str<span class="opt">),</span>
            PCRE2_ZERO_TERMINATED<span class="opt">,</span> <span class="num">0</span><span class="opt">, &amp;</span>error_number<span class="opt">, &amp;</span>error_offset<span class="opt">,</span> <span class="kwc">nullptr</span><span class="opt">));</span>
        <span class="kwa">if</span> <span class="opt">(!</span>_code<span class="opt">)</span>
        <span class="opt">{</span>
            <span class="kwd">throw_pcre2_error</span><span class="opt">(</span>error_number<span class="opt">);</span>
        <span class="opt">}</span>
        <span class="slc">// Now we transform the internal representation into machine code</span>
        <span class="kwd">require_status_good</span><span class="opt">(</span><span class="kwd">pcre2_jit_compile</span><span class="opt">(</span>_code<span class="opt">,</span> PCRE2_JIT_COMPLETE<span class="opt">));</span>
    <span class="opt">}</span>

    <span class="slc">// Allocate PCRE2 objects for applying the regular expression</span>
    <span class="slc">// and storing the result</span>
    <span class="kwc">inline</span> <span class="kwb">void</span> <span class="kwd">allocate_match_data</span><span class="opt">()</span>
    <span class="opt">{</span>
        _match_context <span class="opt">=</span> <span class="kwd">pcre2_match_context_create</span><span class="opt">(</span><span class="kwc">nullptr</span><span class="opt">);</span>
        <span class="kwd">require_allocation_good</span><span class="opt">(</span>_match_context<span class="opt">);</span>

        _match_data <span class="opt">=</span> <span class="kwd">pcre2_match_data_create_from_pattern</span><span class="opt">(</span>_code<span class="opt">,</span> <span class="kwc">nullptr</span><span class="opt">);</span>
        <span class="kwd">require_allocation_good</span><span class="opt">(</span>_match_data<span class="opt">);</span>

        _jit_stack <span class="opt">=</span> <span class="kwd">pcre2_jit_stack_create</span><span class="opt">(</span><span class="num">32</span> <span class="opt">*</span> <span class="num">1024</span><span class="opt">,</span> <span class="num">512</span> <span class="opt">*</span> <span class="num">1024</span><span class="opt">,</span> <span class="kwc">nullptr</span><span class="opt">);</span>
        <span class="kwd">require_allocation_good</span><span class="opt">(</span>_jit_stack<span class="opt">);</span>

        <span class="kwd">pcre2_jit_stack_assign</span><span class="opt">(</span>_match_context<span class="opt">,</span> <span class="kwc">nullptr</span><span class="opt">,</span> _jit_stack<span class="opt">);</span>
    <span class="opt">}</span>

    <span class="slc">// Throw runtime_error with error-message from PCRE2</span>
    <span class="kwc">inline</span> <span class="kwb">static void</span> <span class="kwd">throw_pcre2_error</span><span class="opt">(</span><span class="kwb">int</span> status<span class="opt">)</span>
    <span class="opt">{</span>
        <span class="kwc">std</span><span class="opt">::</span>string msg<span class="opt">;</span>
        msg<span class="opt">.</span><span class="kwd">resize</span><span class="opt">(</span><span class="num">1024</span><span class="opt">);</span>
        <span class="kwd">pcre2_get_error_message</span><span class="opt">(</span>status<span class="opt">,</span> <span class="kwd">pcre2_buffer_cast</span><span class="opt">(</span>msg<span class="opt">),</span> msg<span class="opt">.</span><span class="kwd">size</span><span class="opt">());</span>
        <span class="kwa">throw</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwd">runtime_error</span><span class="opt">(</span>msg<span class="opt">.</span><span class="kwd">c_str</span><span class="opt">());</span>
    <span class="opt">}</span>

    <span class="slc">// Throw exception if pinter is nullptr</span>
    <span class="kwc">inline</span> <span class="kwb">static void</span> <span class="kwd">require_allocation_good</span><span class="opt">(</span><span class="kwb">void</span><span class="opt">*</span> ptr<span class="opt">)</span>
    <span class="opt">{</span>
        <span class="kwa">if</span> <span class="opt">(</span>ptr <span class="opt">==</span> <span class="kwc">nullptr</span><span class="opt">)</span>
        <span class="opt">{</span>
            <span class="kwa">throw</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwd">bad_alloc</span><span class="opt">();</span>
        <span class="opt">}</span>
    <span class="opt">}</span>

    <span class="slc">// Throw an exception if a PCRE2 error occurred</span>
    <span class="kwc">inline</span> <span class="kwb">static void</span> <span class="kwd">require_status_good</span><span class="opt">(</span><span class="kwb">int</span> status<span class="opt">)</span>
    <span class="opt">{</span>
        <span class="kwa">if</span> <span class="opt">(</span>status <span class="opt">&lt;</span> <span class="num">0</span> <span class="opt">&amp;&amp;</span> status <span class="opt">!=</span> PCRE2_ERROR_NOMATCH<span class="opt">)</span>
        <span class="opt">{</span>
            <span class="kwd">throw_pcre2_error</span><span class="opt">(</span>status<span class="opt">);</span>
        <span class="opt">}</span>
    <span class="opt">}</span>

    pcre2_code<span class="opt">*</span> _code <span class="opt">=</span> <span class="kwc">nullptr</span><span class="opt">;</span>
    pcre2_match_data<span class="opt">*</span> _match_data <span class="opt">=</span> <span class="kwc">nullptr</span><span class="opt">;</span>
    pcre2_match_context<span class="opt">*</span> _match_context <span class="opt">=</span> <span class="kwc">nullptr</span><span class="opt">;</span>
    pcre2_jit_stack<span class="opt">*</span> _jit_stack <span class="opt">=</span> <span class="kwc">nullptr</span><span class="opt">;</span>
<span class="opt">};</span>

<span class="slc">/// Patterns for counting</span>
<span class="kwb">const char</span><span class="opt">*</span> <span class="kwb">const</span> count_regexes<span class="opt">[] = {</span> <span class="str">&quot;agggtaaa|tttaccct&quot;</span><span class="opt">,</span>
    <span class="str">&quot;[cgt]gggtaaa|tttaccc[acg]&quot;</span><span class="opt">,</span> <span class="str">&quot;a[act]ggtaaa|tttacc[agt]t&quot;</span><span class="opt">,</span>
    <span class="str">&quot;ag[act]gtaaa|tttac[agt]ct&quot;</span><span class="opt">,</span> <span class="str">&quot;agg[act]taaa|ttta[agt]cct&quot;</span><span class="opt">,</span>
    <span class="str">&quot;aggg[acg]aaa|ttt[cgt]ccct&quot;</span><span class="opt">,</span> <span class="str">&quot;agggt[cgt]aa|tt[acg]accct&quot;</span><span class="opt">,</span>
    <span class="str">&quot;agggta[cgt]a|t[acg]taccct&quot;</span><span class="opt">,</span> <span class="str">&quot;agggtaa[cgt]|[acg]ttaccct&quot;</span> <span class="opt">};</span>

<span class="kwa">using</span> regex_replace_spec <span class="opt">=</span> <span class="kwc">std</span><span class="opt">::</span>pair<span class="opt">&lt;</span><span class="kwb">const char</span><span class="opt">*</span> <span class="kwb">const</span><span class="opt">,</span> <span class="kwb">const char</span><span class="opt">*</span> <span class="kwb">const</span><span class="opt">&gt;;</span>

<span class="slc">/// Patterns + replacements for replacement operation</span>
<span class="kwb">const</span> regex_replace_spec replace_specs<span class="opt">[] = { {</span> <span class="str">&quot;tHa[Nt]&quot;</span><span class="opt">,</span> <span class="str">&quot;&lt;4&gt;&quot;</span> <span class="opt">},</span>
    <span class="opt">{</span> <span class="str">&quot;aND|caN|Ha[DS]|WaS&quot;</span><span class="opt">,</span> <span class="str">&quot;&lt;3&gt;&quot;</span> <span class="opt">}, {</span> <span class="str">&quot;a[NSt]|BY&quot;</span><span class="opt">,</span> <span class="str">&quot;&lt;2&gt;&quot;</span> <span class="opt">}, {</span> <span class="str">&quot;&lt;[^&gt;]*&gt;&quot;</span><span class="opt">,</span> <span class="str">&quot;|&quot;</span> <span class="opt">},</span>
    <span class="opt">{</span> <span class="str">&quot;</span><span class="esc">\\</span><span class="str">|[^|][^|]*</span><span class="esc">\\</span><span class="str">|&quot;</span><span class="opt">,</span> <span class="str">&quot;-&quot;</span> <span class="opt">} };</span>

<span class="slc">// Run asynchronous tasks in separate thread</span>
<span class="kwb">const</span> <span class="kwc">auto</span> launch_type <span class="opt">=</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwc">launch</span><span class="opt">::</span>async<span class="opt">;</span>

<span class="slc">// Read all data from input-stream and return as string</span>
<span class="kwc">inline std</span><span class="opt">::</span>string <span class="kwd">slurp</span><span class="opt">(</span><span class="kwc">std</span><span class="opt">::</span>istream<span class="opt">&amp;</span> in<span class="opt">)</span>
<span class="opt">{</span>
    <span class="kwc">std</span><span class="opt">::</span>string input_data<span class="opt">;</span>
    <span class="kwb">size_t</span> buffer_size <span class="opt">=</span> <span class="num">1u</span> <span class="opt">&lt;&lt;</span> <span class="num">14</span><span class="opt">;</span>
    input_data<span class="opt">.</span><span class="kwd">resize</span><span class="opt">(</span>buffer_size<span class="opt">);</span>
    <span class="kwb">size_t</span> space_left <span class="opt">=</span> buffer_size<span class="opt">;</span>
    <span class="kwa">while</span> <span class="opt">(</span>in<span class="opt">.</span><span class="kwd">good</span><span class="opt">())</span>
    <span class="opt">{</span>
        <span class="kwa">if</span> <span class="opt">(!</span>space_left<span class="opt">)</span>
        <span class="opt">{</span>
            space_left <span class="opt">=</span> buffer_size<span class="opt">;</span>
            buffer_size <span class="opt">*=</span> <span class="num">2</span><span class="opt">;</span>
            input_data<span class="opt">.</span><span class="kwd">resize</span><span class="opt">(</span>buffer_size<span class="opt">);</span>
        <span class="opt">}</span>
        in<span class="opt">.</span><span class="kwd">read</span><span class="opt">(&amp;</span>input_data<span class="opt">[</span>buffer_size <span class="opt">-</span> space_left<span class="opt">],</span> space_left<span class="opt">);</span>
        space_left <span class="opt">-=</span> in<span class="opt">.</span><span class="kwd">gcount</span><span class="opt">();</span>
    <span class="opt">}</span>
    input_data<span class="opt">.</span><span class="kwd">resize</span><span class="opt">(</span>buffer_size <span class="opt">-</span> space_left<span class="opt">);</span>
    <span class="kwa">return</span> input_data<span class="opt">;</span>
<span class="opt">}</span>

<span class="kwa">using</span> counter_list <span class="opt">=</span> <span class="kwc">std</span><span class="opt">::</span>vector<span class="opt">&lt;</span><span class="kwb">size_t</span><span class="opt">&gt;;</span>

<span class="kwc">inline</span> counter_list <span class="kwd">count_occurrences</span><span class="opt">(</span><span class="kwb">const</span> <span class="kwc">std</span><span class="opt">::</span>string<span class="opt">&amp;</span> subject<span class="opt">)</span>
<span class="opt">{</span>
    counter_list counters<span class="opt">;</span>
    <span class="kwc">std</span><span class="opt">::</span>vector<span class="opt">&lt;</span><span class="kwc">std</span><span class="opt">::</span>future<span class="opt">&lt;</span><span class="kwb">size_t</span><span class="opt">&gt;&gt;</span> tasks<span class="opt">;</span>
    <span class="kwa">for</span> <span class="opt">(</span><span class="kwb">const</span> <span class="kwc">auto</span><span class="opt">&amp;</span> regex_str <span class="opt">:</span> count_regexes<span class="opt">)</span>
    <span class="opt">{</span>
        tasks<span class="opt">.</span><span class="kwd">emplace_back</span><span class="opt">(</span>
            <span class="slc">// Launch task in separate thread</span>
            <span class="kwc">std</span><span class="opt">::</span><span class="kwd">async</span><span class="opt">(</span>launch_type<span class="opt">, [&amp;</span>subject<span class="opt">, &amp;</span>regex_str<span class="opt">]() -&gt;</span> <span class="kwb">size_t</span> <span class="opt">{</span>
                regex <span class="kwd">re</span><span class="opt">(</span>regex_str<span class="opt">);</span>
                <span class="kwa">return</span> re<span class="opt">.</span><span class="kwd">count_matches</span><span class="opt">(</span>subject<span class="opt">);</span>
            <span class="opt">}));</span>
    <span class="opt">}</span>
    counter_list results<span class="opt">;</span>
    <span class="slc">// Get results from all asychronous tasks and store them in &quot;results&quot;</span>
    <span class="kwc">std</span><span class="opt">::</span><span class="kwd">transform</span><span class="opt">(</span>tasks<span class="opt">.</span><span class="kwd">begin</span><span class="opt">(),</span> tasks<span class="opt">.</span><span class="kwd">end</span><span class="opt">(),</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwd">back_inserter</span><span class="opt">(</span>results<span class="opt">),</span>
        <span class="opt">[](</span><span class="kwc">auto</span><span class="opt">&amp;</span> task<span class="opt">) {</span> <span class="kwa">return</span> task<span class="opt">.</span><span class="kwd">get</span><span class="opt">(); });</span>
    <span class="kwa">return</span> results<span class="opt">;</span>
<span class="opt">}</span>

<span class="kwc">inline std</span><span class="opt">::</span>string <span class="kwd">replace_patterns</span><span class="opt">(</span><span class="kwb">const</span> <span class="kwc">std</span><span class="opt">::</span>string<span class="opt">&amp;</span> subject<span class="opt">)</span>
<span class="opt">{</span>
    PCRE2_SIZE current_size <span class="opt">=</span> subject<span class="opt">.</span><span class="kwd">size</span><span class="opt">();</span>
    <span class="slc">// A heuristic value new size = original_size * 1.1</span>
    <span class="kwb">const</span> PCRE2_SIZE buffer_size <span class="opt">=</span> current_size <span class="opt">*</span> <span class="num">1.1</span><span class="opt">;</span>
    <span class="kwc">std</span><span class="opt">::</span>string <span class="kwd">source</span><span class="opt">(</span>subject<span class="opt">);</span>
    <span class="kwc">std</span><span class="opt">::</span>string sink<span class="opt">;</span>
    source<span class="opt">.</span><span class="kwd">resize</span><span class="opt">(</span>buffer_size<span class="opt">);</span>
    sink<span class="opt">.</span><span class="kwd">resize</span><span class="opt">(</span>buffer_size<span class="opt">);</span>
    <span class="kwa">for</span> <span class="opt">(</span><span class="kwc">auto</span> replace_spec <span class="opt">:</span> replace_specs<span class="opt">)</span>
    <span class="opt">{</span>
        <span class="kwc">auto</span> re <span class="opt">=</span> <span class="kwd">regex</span><span class="opt">(</span>replace_spec<span class="opt">.</span>first<span class="opt">);</span>
        PCRE2_SPTR8 pcre2_src <span class="opt">=</span> <span class="kwd">pcre2_string_cast</span><span class="opt">(</span>source<span class="opt">);</span>
        PCRE2_UCHAR<span class="opt">*</span> pcre2_sink <span class="opt">=</span> <span class="kwd">pcre2_buffer_cast</span><span class="opt">(</span>sink<span class="opt">);</span>
        current_size <span class="opt">=</span> re<span class="opt">.</span><span class="kwd">replace_all</span><span class="opt">(</span>replace_spec<span class="opt">.</span>second<span class="opt">,</span> pcre2_src<span class="opt">,</span>
            pcre2_src <span class="opt">+</span> current_size<span class="opt">,</span> pcre2_sink<span class="opt">,</span> pcre2_sink <span class="opt">+</span> buffer_size<span class="opt">);</span>
        <span class="kwc">std</span><span class="opt">::</span><span class="kwd">swap</span><span class="opt">(</span>source<span class="opt">,</span> sink<span class="opt">);</span>
    <span class="opt">}</span>
    source<span class="opt">.</span><span class="kwd">resize</span><span class="opt">(</span>current_size<span class="opt">);</span>
    <span class="kwa">return</span> source<span class="opt">;</span>
<span class="opt">}</span>

<span class="kwb">int</span> <span class="kwd">main</span><span class="opt">()</span>
<span class="opt">{</span>
    <span class="kwa">try</span>
    <span class="opt">{</span>
        <span class="kwc">std</span><span class="opt">::</span>string input <span class="opt">=</span> <span class="kwd">slurp</span><span class="opt">(</span><span class="kwc">std</span><span class="opt">::</span>cin<span class="opt">);</span>
        <span class="kwc">auto</span> clean_input_regex <span class="opt">=</span> <span class="kwd">regex</span><span class="opt">(</span>R<span class="str">&quot;(&gt;[^\n]*\n|\n)&quot;</span><span class="opt">);</span>
        <span class="slc">// Remove newlines and comments</span>
        <span class="kwc">std</span><span class="opt">::</span>string clean_input <span class="opt">=</span> clean_input_regex<span class="opt">.</span><span class="kwd">replace_all</span><span class="opt">(</span><span class="str">&quot;&quot;</span><span class="opt">,</span> input<span class="opt">);</span>

        <span class="slc">// Launch counting of occurrences of patterns in separate thread</span>
        <span class="kwc">auto</span> count_task
            <span class="opt">=</span> <span class="kwc">std</span><span class="opt">::</span><span class="kwd">async</span><span class="opt">(</span>launch_type<span class="opt">,</span> count_occurrences<span class="opt">,</span> clean_input<span class="opt">);</span>

        <span class="slc">// Replace patterns with strings</span>
        <span class="kwc">auto</span> processed_input <span class="opt">=</span> <span class="kwd">replace_patterns</span><span class="opt">(</span>clean_input<span class="opt">);</span>
        <span class="slc">// Get results from the thread that counted the occurrences of patterns</span>
        <span class="kwc">auto</span> counters <span class="opt">=</span> count_task<span class="opt">.</span><span class="kwd">get</span><span class="opt">();</span>

        <span class="slc">// Print occurrences to stdout</span>
        <span class="kwb">size_t</span> i <span class="opt">=</span> <span class="num">0</span><span class="opt">;</span>
        <span class="kwa">for</span> <span class="opt">(</span><span class="kwc">auto</span> counter <span class="opt">:</span> counters<span class="opt">)</span>
        <span class="opt">{</span>
            <span class="kwc">std</span><span class="opt">::</span>cout <span class="opt">&lt;&lt;</span> count_regexes<span class="opt">[</span>i<span class="opt">++] &lt;&lt;</span> <span class="str">&quot; &quot;</span> <span class="opt">&lt;&lt;</span> counter <span class="opt">&lt;&lt;</span> <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span><span class="opt">;</span>
        <span class="opt">}</span>

        <span class="slc">// Print string lengths to stdout</span>
        <span class="kwc">std</span><span class="opt">::</span>cout <span class="opt">&lt;&lt;</span> <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span>
                  <span class="opt">&lt;&lt;</span> input<span class="opt">.</span><span class="kwd">size</span><span class="opt">() &lt;&lt;</span> <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span>
                  <span class="opt">&lt;&lt;</span> clean_input<span class="opt">.</span><span class="kwd">size</span><span class="opt">() &lt;&lt;</span> <span class="str">&quot;</span><span class="esc">\n</span><span class="str">&quot;</span>
                  <span class="opt">&lt;&lt;</span> processed_input<span class="opt">.</span><span class="kwd">size</span><span class="opt">() &lt;&lt;</span> <span class="kwc">std</span><span class="opt">::</span>endl<span class="opt">;</span>
        <span class="kwa">return</span> <span class="num">0</span><span class="opt">;</span>
    <span class="opt">}</span>
    <span class="kwa">catch</span> <span class="opt">(</span><span class="kwc">std</span><span class="opt">::</span>exception<span class="opt">&amp;</span> e<span class="opt">)</span>
    <span class="opt">{</span>
        <span class="kwc">std</span><span class="opt">::</span>cerr <span class="opt">&lt;&lt;</span> <span class="str">&quot;Exception caught: &quot;</span> <span class="opt">&lt;&lt;</span> e<span class="opt">.</span><span class="kwd">what</span><span class="opt">() &lt;&lt;</span> <span class="kwc">std</span><span class="opt">::</span>endl<span class="opt">;</span>
    <span class="opt">}</span>
    <span class="kwa">return</span> <span class="num">1</span><span class="opt">;</span>
<span class="opt">}</span>
    </pre>
  </section>
  <section>
    <div>
      <h2 id="log">notes, command-line, and program output</h2>
    </div>
    <pre>
NOTES:
64-bit Ubuntu quad core
g++ (Ubuntu 9.3.0-10ubuntu2) 9.3.0


Mon, 04 May 2020 19:43:44 GMT

MAKE:
/usr/bin/g++ -c -pipe -O3 -fomit-frame-pointer -march=core2  -std=c++17 regexredux.gpp-6.c++ -o regexredux.gpp-6.c++.o &amp;&amp;  \
        /usr/bin/g++ regexredux.gpp-6.c++.o -o regexredux.gpp-6.gpp_run -lpcre2-8 -lpthread 
rm regexredux.gpp-6.c++

8.35s to complete and log all make actions

COMMAND LINE:
./regexredux.gpp-6.gpp_run 0 &lt; regexredux-input5000000.txt

PROGRAM OUTPUT:
agggtaaa|tttaccct 356
[cgt]gggtaaa|tttaccc[acg] 1250
a[act]ggtaaa|tttacc[agt]t 4252
ag[act]gtaaa|tttac[agt]ct 2894
agg[act]taaa|ttta[agt]cct 5435
aggg[acg]aaa|ttt[cgt]ccct 1537
agggt[cgt]aa|tt[acg]accct 1431
agggta[cgt]a|t[acg]taccct 1608
agggtaa[cgt]|[acg]ttaccct 2178

50833411
50000000
27388361
    </pre>
  </section>
</article>
<footer>
  <nav>
    <ul>
      <li><a href="https://salsa.debian.org/benchmarksgame-team/benchmarksgame/blob/master/CONTRIBUTING.md#contribute-source-code-for-measurement"><span>Contribute your own program</span></a>
      <li><a href="../../license.html"><span>3-Clause BSD License</span></a>
    </ul>
  </nav>
</footer>

